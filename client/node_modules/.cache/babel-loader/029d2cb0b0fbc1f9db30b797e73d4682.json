{"ast":null,"code":"/**\n * Machine id.\n *\n * Create a random 3-byte value (i.e. unique for this\n * process). Other drivers use a md5 of the machine id here, but\n * that would mean an asyc call to gethostname, so we don't bother.\n * @ignore\n */\nvar MACHINE_ID = parseInt(Math.random() * 0xFFFFFF, 10); // Regular expression that checks for hex value\n\nvar checkForHexRegExp = new RegExp(\"^[0-9a-fA-F]{24}$\");\n/**\n* Create a new ObjectID instance\n*\n* @class\n* @param {(string|number)} id Can be a 24 byte hex string, 12 byte binary string or a Number.\n* @property {number} generationTime The generation time of this ObjectId instance\n* @return {ObjectID} instance of ObjectID.\n*/\n\nvar ObjectID = function ObjectID(id) {\n  // Duck-typing to support ObjectId from different npm packages\n  if (id instanceof ObjectID) return id;\n  if (!(this instanceof ObjectID)) return new ObjectID(id);\n  this._bsontype = 'ObjectID';\n  var __id = null;\n  var valid = ObjectID.isValid(id); // Throw an error if it's not a valid setup\n\n  if (!valid && id != null) {\n    throw new Error(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\");\n  } else if (valid && typeof id == 'string' && id.length == 24) {\n    return ObjectID.createFromHexString(id);\n  } else if (id == null || typeof id == 'number') {\n    // convert to 12 byte binary string\n    this.id = this.generate(id);\n  } else if (id != null && id.length === 12) {\n    // assume 12 byte string\n    this.id = id;\n  } else if (id != null && id.toHexString) {\n    // Duck-typing to support ObjectId from different npm packages\n    return id;\n  } else {\n    throw new Error(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\");\n  }\n\n  if (ObjectID.cacheHexString) this.__id = this.toHexString();\n}; // Allow usage of ObjectId as well as ObjectID\n\n\nvar ObjectId = ObjectID; // Precomputed hex table enables speedy hex string conversion\n\nvar hexTable = [];\n\nfor (var i = 0; i < 256; i++) {\n  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);\n}\n/**\n* Return the ObjectID id as a 24 byte hex string representation\n*\n* @method\n* @return {string} return the 24 byte hex string representation.\n*/\n\n\nObjectID.prototype.toHexString = function () {\n  if (ObjectID.cacheHexString && this.__id) return this.__id;\n  var hexString = '';\n\n  if (!this.id || !this.id.length) {\n    throw new Error('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');\n  }\n\n  if (this.id instanceof _Buffer) {\n    hexString = convertToHex(this.id);\n    if (ObjectID.cacheHexString) this.__id = hexString;\n    return hexString;\n  }\n\n  for (var i = 0; i < this.id.length; i++) {\n    hexString += hexTable[this.id.charCodeAt(i)];\n  }\n\n  if (ObjectID.cacheHexString) this.__id = hexString;\n  return hexString;\n};\n/**\n* Update the ObjectID index used in generating new ObjectID's on the driver\n*\n* @method\n* @return {number} returns next index value.\n* @ignore\n*/\n\n\nObjectID.prototype.get_inc = function () {\n  return ObjectID.index = (ObjectID.index + 1) % 0xFFFFFF;\n};\n/**\n* Update the ObjectID index used in generating new ObjectID's on the driver\n*\n* @method\n* @return {number} returns next index value.\n* @ignore\n*/\n\n\nObjectID.prototype.getInc = function () {\n  return this.get_inc();\n};\n/**\n* Generate a 12 byte id buffer used in ObjectID's\n*\n* @method\n* @param {number} [time] optional parameter allowing to pass in a second based timestamp.\n* @return {Buffer} return the 12 byte id buffer string.\n*/\n\n\nObjectID.prototype.generate = function (time) {\n  if ('number' != typeof time) {\n    time = ~~(Date.now() / 1000);\n  } // Use pid\n\n\n  var pid = (typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid) % 0xFFFF;\n  var inc = this.get_inc(); // Buffer used\n\n  var buffer = new Buffer(12); // Encode time\n\n  buffer[3] = time & 0xff;\n  buffer[2] = time >> 8 & 0xff;\n  buffer[1] = time >> 16 & 0xff;\n  buffer[0] = time >> 24 & 0xff; // Encode machine\n\n  buffer[6] = MACHINE_ID & 0xff;\n  buffer[5] = MACHINE_ID >> 8 & 0xff;\n  buffer[4] = MACHINE_ID >> 16 & 0xff; // Encode pid\n\n  buffer[8] = pid & 0xff;\n  buffer[7] = pid >> 8 & 0xff; // Encode index\n\n  buffer[11] = inc & 0xff;\n  buffer[10] = inc >> 8 & 0xff;\n  buffer[9] = inc >> 16 & 0xff; // Return the buffer\n\n  return buffer;\n};\n/**\n* Converts the id into a 24 byte hex string for printing\n*\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\n\n\nObjectID.prototype.toString = function () {\n  return this.toHexString();\n};\n/**\n* Converts to a string representation of this Id.\n*\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\n\n\nObjectID.prototype.inspect = ObjectID.prototype.toString;\n/**\n* Converts to its JSON representation.\n*\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\n\nObjectID.prototype.toJSON = function () {\n  return this.toHexString();\n};\n/**\n* Compares the equality of this ObjectID with `otherID`.\n*\n* @method\n* @param {object} otherID ObjectID instance to compare against.\n* @return {boolean} the result of comparing two ObjectID's\n*/\n\n\nObjectID.prototype.equals = function equals(otherId) {\n  var id;\n\n  if (otherId instanceof ObjectID) {\n    return this.toString() == otherId.toString();\n  } else if (typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 12 && this.id instanceof _Buffer) {\n    return otherId === this.id.toString('binary');\n  } else if (typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 24) {\n    return otherId === this.toHexString();\n  } else if (typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 12) {\n    return otherId === this.id;\n  } else if (otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {\n    return otherId.toHexString() === this.toHexString();\n  } else {\n    return false;\n  }\n};\n/**\n* Returns the generation date (accurate up to the second) that this ID was generated.\n*\n* @method\n* @return {date} the generation date\n*/\n\n\nObjectID.prototype.getTimestamp = function () {\n  var timestamp = new Date();\n  var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;\n  timestamp.setTime(Math.floor(time) * 1000);\n  return timestamp;\n};\n/**\n* @ignore\n*/\n\n\nObjectID.index = ~~(Math.random() * 0xFFFFFF);\n/**\n* @ignore\n*/\n\nObjectID.createPk = function createPk() {\n  return new ObjectID();\n};\n/**\n* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.\n*\n* @method\n* @param {number} time an integer number representing a number of seconds.\n* @return {ObjectID} return the created ObjectID\n*/\n\n\nObjectID.createFromTime = function createFromTime(time) {\n  var buffer = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); // Encode time into first 4 bytes\n\n  buffer[3] = time & 0xff;\n  buffer[2] = time >> 8 & 0xff;\n  buffer[1] = time >> 16 & 0xff;\n  buffer[0] = time >> 24 & 0xff; // Return the new objectId\n\n  return new ObjectID(buffer);\n}; // Lookup tables\n\n\nvar encodeLookup = '0123456789abcdef'.split('');\nvar decodeLookup = [];\nvar i = 0;\n\nwhile (i < 10) decodeLookup[0x30 + i] = i++;\n\nwhile (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++;\n\nvar _Buffer = Buffer;\n\nvar convertToHex = function (bytes) {\n  return bytes.toString('hex');\n};\n/**\n* Creates an ObjectID from a hex string representation of an ObjectID.\n*\n* @method\n* @param {string} hexString create a ObjectID from a passed in 24 byte hexstring.\n* @return {ObjectID} return the created ObjectID\n*/\n\n\nObjectID.createFromHexString = function createFromHexString(string) {\n  // Throw an error if it's not a valid setup\n  if (typeof string === 'undefined' || string != null && string.length != 24) throw new Error(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\");\n  var length = string.length;\n\n  if (length > 12 * 2) {\n    throw new Error('Id cannot be longer than 12 bytes');\n  } // Calculate lengths\n\n\n  var sizeof = length >> 1;\n  var array = new _Buffer(sizeof);\n  var n = 0;\n  var i = 0;\n\n  while (i < length) {\n    array[n++] = decodeLookup[string.charCodeAt(i++)] << 4 | decodeLookup[string.charCodeAt(i++)];\n  }\n\n  return new ObjectID(array);\n};\n/**\n* Checks if a value is a valid bson ObjectId\n*\n* @method\n* @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.\n*/\n\n\nObjectID.isValid = function isValid(id) {\n  if (id == null) return false;\n\n  if (typeof id == 'number') {\n    return true;\n  }\n\n  if (typeof id == 'string') {\n    return id.length == 12 || id.length == 24 && checkForHexRegExp.test(id);\n  }\n\n  if (id instanceof ObjectID) {\n    return true;\n  }\n\n  if (id instanceof _Buffer) {\n    return true;\n  } // Duck-Typing detection of ObjectId like objects\n\n\n  if (id.toHexString) {\n    return id.id.length == 12 || id.id.length == 24 && checkForHexRegExp.test(id.id);\n  }\n\n  return false;\n};\n/**\n* @ignore\n*/\n\n\nObject.defineProperty(ObjectID.prototype, \"generationTime\", {\n  enumerable: true,\n  get: function () {\n    return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;\n  },\n  set: function (value) {\n    // Encode time into first 4 bytes\n    this.id[3] = value & 0xff;\n    this.id[2] = value >> 8 & 0xff;\n    this.id[1] = value >> 16 & 0xff;\n    this.id[0] = value >> 24 & 0xff;\n  }\n});\n/**\n * Expose.\n */\n\nmodule.exports = ObjectID;\nmodule.exports.ObjectID = ObjectID;\nmodule.exports.ObjectId = ObjectID;","map":{"version":3,"sources":["C:/Users/SATAN/darelist/client/node_modules/bson/lib/bson/objectid.js"],"names":["MACHINE_ID","parseInt","Math","random","checkForHexRegExp","RegExp","ObjectID","id","_bsontype","__id","valid","isValid","Error","length","createFromHexString","generate","toHexString","cacheHexString","ObjectId","hexTable","i","toString","prototype","hexString","JSON","stringify","_Buffer","convertToHex","charCodeAt","get_inc","index","getInc","time","Date","now","pid","process","floor","inc","buffer","Buffer","inspect","toJSON","equals","otherId","getTimestamp","timestamp","setTime","createPk","createFromTime","encodeLookup","split","decodeLookup","bytes","string","sizeof","array","n","test","Object","defineProperty","enumerable","get","set","value","module","exports"],"mappings":"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","sourcesContent":["/**\n * Machine id.\n *\n * Create a random 3-byte value (i.e. unique for this\n * process). Other drivers use a md5 of the machine id here, but\n * that would mean an asyc call to gethostname, so we don't bother.\n * @ignore\n */\nvar MACHINE_ID = parseInt(Math.random() * 0xFFFFFF, 10);\n\n// Regular expression that checks for hex value\nvar checkForHexRegExp = new RegExp(\"^[0-9a-fA-F]{24}$\");\n\n/**\n* Create a new ObjectID instance\n*\n* @class\n* @param {(string|number)} id Can be a 24 byte hex string, 12 byte binary string or a Number.\n* @property {number} generationTime The generation time of this ObjectId instance\n* @return {ObjectID} instance of ObjectID.\n*/\nvar ObjectID = function ObjectID(id) {\n  // Duck-typing to support ObjectId from different npm packages\n  if(id instanceof ObjectID) return id;\n  if(!(this instanceof ObjectID)) return new ObjectID(id);\n\n  this._bsontype = 'ObjectID';\n\n  var __id = null;\n  var valid = ObjectID.isValid(id);\n\n  // Throw an error if it's not a valid setup\n  if(!valid && id != null){\n    throw new Error(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\");\n  } else if(valid && typeof id == 'string' && id.length == 24) {\n    return ObjectID.createFromHexString(id);\n  } else if(id == null || typeof id == 'number') {\n    // convert to 12 byte binary string\n    this.id = this.generate(id);\n  } else if(id != null && id.length === 12) {\n    // assume 12 byte string\n    this.id = id;\n  } else if(id != null && id.toHexString) {\n    // Duck-typing to support ObjectId from different npm packages\n    return id;\n  } else {\n    throw new Error(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\");\n  }\n\n  if(ObjectID.cacheHexString) this.__id = this.toHexString();\n};\n\n// Allow usage of ObjectId as well as ObjectID\nvar ObjectId = ObjectID;\n\n// Precomputed hex table enables speedy hex string conversion\nvar hexTable = [];\nfor (var i = 0; i < 256; i++) {\n  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);\n}\n\n/**\n* Return the ObjectID id as a 24 byte hex string representation\n*\n* @method\n* @return {string} return the 24 byte hex string representation.\n*/\nObjectID.prototype.toHexString = function() {\n  if(ObjectID.cacheHexString && this.__id) return this.__id;\n\n  var hexString = '';\n  if(!this.id || !this.id.length) {\n    throw new Error('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');\n  }\n\n  if(this.id instanceof _Buffer) {\n    hexString = convertToHex(this.id);\n    if(ObjectID.cacheHexString) this.__id = hexString;\n    return hexString;\n  }\n\n  for (var i = 0; i < this.id.length; i++) {\n    hexString += hexTable[this.id.charCodeAt(i)];\n  }\n\n  if(ObjectID.cacheHexString) this.__id = hexString;\n  return hexString;\n};\n\n/**\n* Update the ObjectID index used in generating new ObjectID's on the driver\n*\n* @method\n* @return {number} returns next index value.\n* @ignore\n*/\nObjectID.prototype.get_inc = function() {\n  return ObjectID.index = (ObjectID.index + 1) % 0xFFFFFF;\n};\n\n/**\n* Update the ObjectID index used in generating new ObjectID's on the driver\n*\n* @method\n* @return {number} returns next index value.\n* @ignore\n*/\nObjectID.prototype.getInc = function() {\n  return this.get_inc();\n};\n\n/**\n* Generate a 12 byte id buffer used in ObjectID's\n*\n* @method\n* @param {number} [time] optional parameter allowing to pass in a second based timestamp.\n* @return {Buffer} return the 12 byte id buffer string.\n*/\nObjectID.prototype.generate = function(time) {\n  if ('number' != typeof time) {\n    time = ~~(Date.now()/1000);\n  }\n\n  // Use pid\n  var pid = (typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid) % 0xFFFF;\n  var inc = this.get_inc();\n  // Buffer used\n  var buffer = new Buffer(12);\n  // Encode time\n  buffer[3] = time & 0xff;\n  buffer[2] = (time >> 8) & 0xff;\n  buffer[1] = (time >> 16) & 0xff;\n  buffer[0] = (time >> 24) & 0xff;\n  // Encode machine\n  buffer[6] = MACHINE_ID & 0xff;\n  buffer[5] = (MACHINE_ID >> 8) & 0xff;\n  buffer[4] = (MACHINE_ID >> 16) & 0xff;\n  // Encode pid\n  buffer[8] = pid & 0xff;\n  buffer[7] = (pid >> 8) & 0xff;\n  // Encode index\n  buffer[11] = inc & 0xff;\n  buffer[10] = (inc >> 8) & 0xff;\n  buffer[9] = (inc >> 16) & 0xff;\n  // Return the buffer\n  return buffer;\n};\n\n/**\n* Converts the id into a 24 byte hex string for printing\n*\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\nObjectID.prototype.toString = function() {\n  return this.toHexString();\n};\n\n/**\n* Converts to a string representation of this Id.\n*\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\nObjectID.prototype.inspect = ObjectID.prototype.toString;\n\n/**\n* Converts to its JSON representation.\n*\n* @return {String} return the 24 byte hex string representation.\n* @ignore\n*/\nObjectID.prototype.toJSON = function() {\n  return this.toHexString();\n};\n\n/**\n* Compares the equality of this ObjectID with `otherID`.\n*\n* @method\n* @param {object} otherID ObjectID instance to compare against.\n* @return {boolean} the result of comparing two ObjectID's\n*/\nObjectID.prototype.equals = function equals (otherId) {\n  var id;\n\n  if(otherId instanceof ObjectID) {\n    return this.toString() == otherId.toString();\n  } else if(typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 12 && this.id instanceof _Buffer) {\n    return otherId === this.id.toString('binary');\n  } else if(typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 24) {\n    return otherId === this.toHexString();\n  } else if(typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 12) {\n    return otherId === this.id;\n  } else if(otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {\n    return otherId.toHexString() === this.toHexString();\n  } else {\n    return false;\n  }\n}\n\n/**\n* Returns the generation date (accurate up to the second) that this ID was generated.\n*\n* @method\n* @return {date} the generation date\n*/\nObjectID.prototype.getTimestamp = function() {\n  var timestamp = new Date();\n  var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;\n  timestamp.setTime(Math.floor(time) * 1000);\n  return timestamp;\n}\n\n/**\n* @ignore\n*/\nObjectID.index = ~~(Math.random() * 0xFFFFFF);\n\n/**\n* @ignore\n*/\nObjectID.createPk = function createPk () {\n  return new ObjectID();\n};\n\n/**\n* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.\n*\n* @method\n* @param {number} time an integer number representing a number of seconds.\n* @return {ObjectID} return the created ObjectID\n*/\nObjectID.createFromTime = function createFromTime (time) {\n  var buffer = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n  // Encode time into first 4 bytes\n  buffer[3] = time & 0xff;\n  buffer[2] = (time >> 8) & 0xff;\n  buffer[1] = (time >> 16) & 0xff;\n  buffer[0] = (time >> 24) & 0xff;\n  // Return the new objectId\n  return new ObjectID(buffer);\n};\n\n// Lookup tables\nvar encodeLookup = '0123456789abcdef'.split('')\nvar decodeLookup = []\nvar i = 0\nwhile (i < 10) decodeLookup[0x30 + i] = i++\nwhile (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++\n\nvar _Buffer = Buffer;\nvar convertToHex = function(bytes) {\n  return bytes.toString('hex');\n}\n\n/**\n* Creates an ObjectID from a hex string representation of an ObjectID.\n*\n* @method\n* @param {string} hexString create a ObjectID from a passed in 24 byte hexstring.\n* @return {ObjectID} return the created ObjectID\n*/\nObjectID.createFromHexString = function createFromHexString (string) {\n  // Throw an error if it's not a valid setup\n  if(typeof string === 'undefined' || string != null && string.length != 24)\n    throw new Error(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\");\n\n  var length = string.length;\n\n  if(length > 12*2) {\n    throw new Error('Id cannot be longer than 12 bytes');\n  }\n\n  // Calculate lengths\n  var sizeof = length >> 1;\n  var array = new _Buffer(sizeof);\n  var n = 0;\n  var i = 0;\n\n  while (i < length) {\n    array[n++] = decodeLookup[string.charCodeAt(i++)] << 4 | decodeLookup[string.charCodeAt(i++)]\n  }\n\n  return new ObjectID(array);\n};\n\n/**\n* Checks if a value is a valid bson ObjectId\n*\n* @method\n* @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.\n*/\nObjectID.isValid = function isValid(id) {\n  if(id == null) return false;\n\n  if(typeof id == 'number') {\n    return true;\n  }\n\n  if(typeof id == 'string') {\n    return id.length == 12 || (id.length == 24 && checkForHexRegExp.test(id));\n  }\n\n  if(id instanceof ObjectID) {\n    return true;\n  }\n\n  if(id instanceof _Buffer) {\n    return true;\n  }\n\n  // Duck-Typing detection of ObjectId like objects\n  if(id.toHexString) {\n    return id.id.length == 12 || (id.id.length == 24 && checkForHexRegExp.test(id.id));\n  }\n\n  return false;\n};\n\n/**\n* @ignore\n*/\nObject.defineProperty(ObjectID.prototype, \"generationTime\", {\n   enumerable: true\n , get: function () {\n     return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;\n   }\n , set: function (value) {\n     // Encode time into first 4 bytes\n     this.id[3] = value & 0xff;\n     this.id[2] = (value >> 8) & 0xff;\n     this.id[1] = (value >> 16) & 0xff;\n     this.id[0] = (value >> 24) & 0xff;\n   }\n});\n\n/**\n * Expose.\n */\nmodule.exports = ObjectID;\nmodule.exports.ObjectID = ObjectID;\nmodule.exports.ObjectId = ObjectID;\n"]},"metadata":{},"sourceType":"script"}