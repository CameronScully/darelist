{"ast":null,"code":"\"use strict\";\n\nvar readIEEE754 = require('../float_parser').readIEEE754,\n    f = require('util').format,\n    Long = require('../long').Long,\n    Double = require('../double').Double,\n    Timestamp = require('../timestamp').Timestamp,\n    ObjectID = require('../objectid').ObjectID,\n    Symbol = require('../symbol').Symbol,\n    Code = require('../code').Code,\n    MinKey = require('../min_key').MinKey,\n    MaxKey = require('../max_key').MaxKey,\n    Decimal128 = require('../decimal128'),\n    Int32 = require('../int_32'),\n    DBRef = require('../db_ref').DBRef,\n    BSONRegExp = require('../regexp').BSONRegExp,\n    Binary = require('../binary').Binary;\n\nvar deserialize = function (buffer, options, isArray) {\n  options = options == null ? {} : options;\n  var index = options && options.index ? options.index : 0; // Read the document size\n\n  var size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24; // Ensure buffer is valid size\n\n  if (size < 5 || buffer.length < size || size + index > buffer.length) {\n    throw new Error(\"corrupt bson message\");\n  } // Illegal end value\n\n\n  if (buffer[index + size - 1] != 0) {\n    throw new Error(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n  } // Start deserializtion\n\n\n  return deserializeObject(buffer, index, options, isArray);\n};\n\nvar deserializeObject = function (buffer, index, options, isArray) {\n  var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];\n  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];\n  var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];\n  var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw']; // Return raw bson buffer instead of parsing it\n\n  var raw = options['raw'] == null ? false : options['raw']; // Return BSONRegExp objects instead of native regular expressions\n\n  var bsonRegExp = typeof options['bsonRegExp'] == 'boolean' ? options['bsonRegExp'] : false; // Controls the promotion of values vs wrapper classes\n\n  var promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];\n  var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];\n  var promoteValues = options['promoteValues'] == null ? true : options['promoteValues']; // Set the start index\n\n  var startIndex = index; // Validate that we have at least 4 bytes of buffer\n\n  if (buffer.length < 5) throw new Error(\"corrupt bson message < 5 bytes long\"); // Read the document size\n\n  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; // Ensure buffer is valid size\n\n  if (size < 5 || size > buffer.length) throw new Error(\"corrupt bson message\"); // Create holding object\n\n  var object = isArray ? [] : {}; // Used for arrays to skip having to perform utf8 decoding\n\n  var arrayIndex = 0; // While we have more left data left keep parsing\n\n  while (true) {\n    // Read the type\n    var elementType = buffer[index++]; // If we get a zero it's the last byte, exit\n\n    if (elementType == 0) {\n      break;\n    } // Get the start search index\n\n\n    var i = index; // Locate the end of the c string\n\n    while (buffer[i] !== 0x00 && i < buffer.length) {\n      i++;\n    } // If are at the end of the buffer there is a problem with the document\n\n\n    if (i >= buffer.length) throw new Error(\"Bad BSON Document: illegal CString\");\n    var name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i);\n    index = i + 1;\n\n    if (elementType == BSON.BSON_DATA_STRING) {\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] != 0) throw new Error(\"bad string length in bson\");\n      object[name] = buffer.toString('utf8', index, index + stringSize - 1);\n      index = index + stringSize;\n    } else if (elementType == BSON.BSON_DATA_OID) {\n      var oid = new Buffer(12);\n      buffer.copy(oid, 0, index, index + 12);\n      object[name] = new ObjectID(oid);\n      index = index + 12;\n    } else if (elementType == BSON.BSON_DATA_INT && promoteValues == false) {\n      object[name] = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);\n    } else if (elementType == BSON.BSON_DATA_INT) {\n      object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    } else if (elementType == BSON.BSON_DATA_NUMBER && promoteValues == false) {\n      object[name] = new Double(buffer.readDoubleLE(index));\n      index = index + 8;\n    } else if (elementType == BSON.BSON_DATA_NUMBER) {\n      object[name] = buffer.readDoubleLE(index);\n      index = index + 8;\n    } else if (elementType == BSON.BSON_DATA_DATE) {\n      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      object[name] = new Date(new Long(lowBits, highBits).toNumber());\n    } else if (elementType == BSON.BSON_DATA_BOOLEAN) {\n      if (buffer[index] != 0 && buffer[index] != 1) throw new Error('illegal boolean type value');\n      object[name] = buffer[index++] == 1;\n    } else if (elementType == BSON.BSON_DATA_OBJECT) {\n      var _index = index;\n      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      if (objectSize <= 0 || objectSize > buffer.length - index) throw new Error(\"bad embedded document length in bson\"); // We have a raw value\n\n      if (raw) {\n        object[name] = buffer.slice(index, index + objectSize);\n      } else {\n        object[name] = deserializeObject(buffer, _index, options, false);\n      }\n\n      index = index + objectSize;\n    } else if (elementType == BSON.BSON_DATA_ARRAY) {\n      var _index = index;\n      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      var arrayOptions = options; // Stop index\n\n      var stopIndex = index + objectSize; // All elements of array to be returned as raw bson\n\n      if (fieldsAsRaw && fieldsAsRaw[name]) {\n        arrayOptions = {};\n\n        for (var n in options) arrayOptions[n] = options[n];\n\n        arrayOptions['raw'] = true;\n      }\n\n      object[name] = deserializeObject(buffer, _index, arrayOptions, true);\n      index = index + objectSize;\n      if (buffer[index - 1] != 0) throw new Error('invalid array terminator byte');\n      if (index != stopIndex) throw new Error('corrupted array bson');\n    } else if (elementType == BSON.BSON_DATA_UNDEFINED) {\n      object[name] = undefined;\n    } else if (elementType == BSON.BSON_DATA_NULL) {\n      object[name] = null;\n    } else if (elementType == BSON.BSON_DATA_LONG) {\n      // Unpack the low and high bits\n      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var long = new Long(lowBits, highBits); // Promote the long if possible\n\n      if (promoteLongs && promoteValues == true) {\n        object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n      } else {\n        object[name] = long;\n      }\n    } else if (elementType == BSON.BSON_DATA_DECIMAL128) {\n      // Buffer to contain the decimal bytes\n      var bytes = new Buffer(16); // Copy the next 16 bytes into the bytes buffer\n\n      buffer.copy(bytes, 0, index, index + 16); // Update index\n\n      index = index + 16; // Assign the new Decimal128 value\n\n      var decimal128 = new Decimal128(bytes); // If we have an alternative mapper use that\n\n      object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;\n    } else if (elementType == BSON.BSON_DATA_BINARY) {\n      var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var totalBinarySize = binarySize;\n      var subType = buffer[index++]; // Did we have a negative binary size, throw\n\n      if (binarySize < 0) throw new Error('Negative binary type element size found'); // Is the length longer than the document\n\n      if (binarySize > buffer.length) throw new Error('Binary type size larger than document size'); // Decode as raw Buffer object if options specifies it\n\n      if (buffer['slice'] != null) {\n        // If we have subtype 2 skip the 4 bytes for the size\n        if (subType == Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n          if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to long binary size');\n          if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to short binary size');\n        }\n\n        if (promoteBuffers && promoteValues) {\n          object[name] = buffer.slice(index, index + binarySize);\n        } else {\n          object[name] = new Binary(buffer.slice(index, index + binarySize), subType);\n        }\n      } else {\n        var _buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize); // If we have subtype 2 skip the 4 bytes for the size\n\n\n        if (subType == Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n          if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to long binary size');\n          if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to short binary size');\n        } // Copy the data\n\n\n        for (var i = 0; i < binarySize; i++) {\n          _buffer[i] = buffer[index + i];\n        }\n\n        if (promoteBuffers && promoteValues) {\n          object[name] = _buffer;\n        } else {\n          object[name] = new Binary(_buffer, subType);\n        }\n      } // Update the index\n\n\n      index = index + binarySize;\n    } else if (elementType == BSON.BSON_DATA_REGEXP && bsonRegExp == false) {\n      // Get the start search index\n      var i = index; // Locate the end of the c string\n\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      } // If are at the end of the buffer there is a problem with the document\n\n\n      if (i >= buffer.length) throw new Error(\"Bad BSON Document: illegal CString\"); // Return the C string\n\n      var source = buffer.toString('utf8', index, i); // Create the regexp\n\n      index = i + 1; // Get the start search index\n\n      var i = index; // Locate the end of the c string\n\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      } // If are at the end of the buffer there is a problem with the document\n\n\n      if (i >= buffer.length) throw new Error(\"Bad BSON Document: illegal CString\"); // Return the C string\n\n      var regExpOptions = buffer.toString('utf8', index, i);\n      index = i + 1; // For each option add the corresponding one for javascript\n\n      var optionsArray = new Array(regExpOptions.length); // Parse options\n\n      for (var i = 0; i < regExpOptions.length; i++) {\n        switch (regExpOptions[i]) {\n          case 'm':\n            optionsArray[i] = 'm';\n            break;\n\n          case 's':\n            optionsArray[i] = 'g';\n            break;\n\n          case 'i':\n            optionsArray[i] = 'i';\n            break;\n        }\n      }\n\n      object[name] = new RegExp(source, optionsArray.join(''));\n    } else if (elementType == BSON.BSON_DATA_REGEXP && bsonRegExp == true) {\n      // Get the start search index\n      var i = index; // Locate the end of the c string\n\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      } // If are at the end of the buffer there is a problem with the document\n\n\n      if (i >= buffer.length) throw new Error(\"Bad BSON Document: illegal CString\"); // Return the C string\n\n      var source = buffer.toString('utf8', index, i);\n      index = i + 1; // Get the start search index\n\n      var i = index; // Locate the end of the c string\n\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      } // If are at the end of the buffer there is a problem with the document\n\n\n      if (i >= buffer.length) throw new Error(\"Bad BSON Document: illegal CString\"); // Return the C string\n\n      var regExpOptions = buffer.toString('utf8', index, i);\n      index = i + 1; // Set the object\n\n      object[name] = new BSONRegExp(source, regExpOptions);\n    } else if (elementType == BSON.BSON_DATA_SYMBOL) {\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] != 0) throw new Error(\"bad string length in bson\");\n      object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));\n      index = index + stringSize;\n    } else if (elementType == BSON.BSON_DATA_TIMESTAMP) {\n      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      object[name] = new Timestamp(lowBits, highBits);\n    } else if (elementType == BSON.BSON_DATA_MIN_KEY) {\n      object[name] = new MinKey();\n    } else if (elementType == BSON.BSON_DATA_MAX_KEY) {\n      object[name] = new MaxKey();\n    } else if (elementType == BSON.BSON_DATA_CODE) {\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] != 0) throw new Error(\"bad string length in bson\");\n      var functionString = buffer.toString('utf8', index, index + stringSize - 1); // If we are evaluating the functions\n\n      if (evalFunctions) {\n        var value = null; // If we have cache enabled let's look for the md5 of the function in the cache\n\n        if (cacheFunctions) {\n          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString; // Got to do this to avoid V8 deoptimizing the call due to finding eval\n\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\n        } else {\n          object[name] = isolateEval(functionString);\n        }\n      } else {\n        object[name] = new Code(functionString);\n      } // Update parse index position\n\n\n      index = index + stringSize;\n    } else if (elementType == BSON.BSON_DATA_CODE_W_SCOPE) {\n      var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; // Element cannot be shorter than totalSize + stringSize + documentSize + terminator\n\n      if (totalSize < 4 + 4 + 4 + 1) {\n        throw new Error(\"code_w_scope total size shorter minimum expected length\");\n      } // Get the code string size\n\n\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; // Check if we have a valid string\n\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] != 0) throw new Error(\"bad string length in bson\"); // Javascript function\n\n      var functionString = buffer.toString('utf8', index, index + stringSize - 1); // Update parse index position\n\n      index = index + stringSize; // Parse the element\n\n      var _index = index; // Decode the size of the object document\n\n      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24; // Decode the scope object\n\n      var scopeObject = deserializeObject(buffer, _index, options, false); // Adjust the index\n\n      index = index + objectSize; // Check if field length is to short\n\n      if (totalSize < 4 + 4 + objectSize + stringSize) {\n        throw new Error('code_w_scope total size is to short, truncating scope');\n      } // Check if totalSize field is to long\n\n\n      if (totalSize > 4 + 4 + objectSize + stringSize) {\n        throw new Error('code_w_scope total size is to long, clips outer document');\n      } // If we are evaluating the functions\n\n\n      if (evalFunctions) {\n        // Contains the value we are going to set\n        var value = null; // If we have cache enabled let's look for the md5 of the function in the cache\n\n        if (cacheFunctions) {\n          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString; // Got to do this to avoid V8 deoptimizing the call due to finding eval\n\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\n        } else {\n          object[name] = isolateEval(functionString);\n        }\n\n        object[name].scope = scopeObject;\n      } else {\n        object[name] = new Code(functionString, scopeObject);\n      }\n    } else if (elementType == BSON_DATA_DBPOINTER) {\n      // Get the code string size\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; // Check if we have a valid string\n\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] != 0) throw new Error(\"bad string length in bson\"); // Namespace\n\n      var namespace = buffer.toString('utf8', index, index + stringSize - 1); // Update parse index position\n\n      index = index + stringSize; // Read the oid\n\n      var oidBuffer = new Buffer(12);\n      buffer.copy(oidBuffer, 0, index, index + 12);\n      var oid = new ObjectID(oidBuffer); // Update the index\n\n      index = index + 12; // Split the namespace\n\n      var parts = namespace.split('.');\n      var db = parts.shift();\n      var collection = parts.join('.'); // Upgrade to DBRef type\n\n      object[name] = new DBRef(collection, oid, db);\n    } else {\n      throw new Error(\"Detected unknown BSON type \" + elementType.toString(16) + \" for fieldname \\\"\" + name + \"\\\", are you using the latest BSON parser\");\n    }\n  } // Check if the deserialization was against a valid array/object\n\n\n  if (size != index - startIndex) {\n    if (isArray) throw new Error('corrupt array bson');\n    throw new Error('corrupt object bson');\n  } // Check if we have a db ref object\n\n\n  if (object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);\n  return object;\n};\n/**\n * Ensure eval is isolated.\n *\n * @ignore\n * @api private\n */\n\n\nvar isolateEvalWithHash = function (functionCache, hash, functionString, object) {\n  // Contains the value we are going to set\n  var value = null; // Check for cache hit, eval if missing and return cached function\n\n  if (functionCache[hash] == null) {\n    eval(\"value = \" + functionString);\n    functionCache[hash] = value;\n  } // Set the object\n\n\n  return functionCache[hash].bind(object);\n};\n/**\n * Ensure eval is isolated.\n *\n * @ignore\n * @api private\n */\n\n\nvar isolateEval = function (functionString) {\n  // Contains the value we are going to set\n  var value = null; // Eval the function\n\n  eval(\"value = \" + functionString);\n  return value;\n};\n\nvar BSON = {};\n/**\n * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5\n *\n * @ignore\n * @api private\n */\n\nvar functionCache = BSON.functionCache = {};\n/**\n * Number BSON Type\n *\n * @classconstant BSON_DATA_NUMBER\n **/\n\nBSON.BSON_DATA_NUMBER = 1;\n/**\n * String BSON Type\n *\n * @classconstant BSON_DATA_STRING\n **/\n\nBSON.BSON_DATA_STRING = 2;\n/**\n * Object BSON Type\n *\n * @classconstant BSON_DATA_OBJECT\n **/\n\nBSON.BSON_DATA_OBJECT = 3;\n/**\n * Array BSON Type\n *\n * @classconstant BSON_DATA_ARRAY\n **/\n\nBSON.BSON_DATA_ARRAY = 4;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_BINARY\n **/\n\nBSON.BSON_DATA_BINARY = 5;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_UNDEFINED\n **/\n\nBSON.BSON_DATA_UNDEFINED = 6;\n/**\n * ObjectID BSON Type\n *\n * @classconstant BSON_DATA_OID\n **/\n\nBSON.BSON_DATA_OID = 7;\n/**\n * Boolean BSON Type\n *\n * @classconstant BSON_DATA_BOOLEAN\n **/\n\nBSON.BSON_DATA_BOOLEAN = 8;\n/**\n * Date BSON Type\n *\n * @classconstant BSON_DATA_DATE\n **/\n\nBSON.BSON_DATA_DATE = 9;\n/**\n * null BSON Type\n *\n * @classconstant BSON_DATA_NULL\n **/\n\nBSON.BSON_DATA_NULL = 10;\n/**\n * RegExp BSON Type\n *\n * @classconstant BSON_DATA_REGEXP\n **/\n\nBSON.BSON_DATA_REGEXP = 11;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_DBPOINTER\n **/\n\nBSON.BSON_DATA_DBPOINTER = 12;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_CODE\n **/\n\nBSON.BSON_DATA_CODE = 13;\n/**\n * Symbol BSON Type\n *\n * @classconstant BSON_DATA_SYMBOL\n **/\n\nBSON.BSON_DATA_SYMBOL = 14;\n/**\n * Code with Scope BSON Type\n *\n * @classconstant BSON_DATA_CODE_W_SCOPE\n **/\n\nBSON.BSON_DATA_CODE_W_SCOPE = 15;\n/**\n * 32 bit Integer BSON Type\n *\n * @classconstant BSON_DATA_INT\n **/\n\nBSON.BSON_DATA_INT = 16;\n/**\n * Timestamp BSON Type\n *\n * @classconstant BSON_DATA_TIMESTAMP\n **/\n\nBSON.BSON_DATA_TIMESTAMP = 17;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_LONG\n **/\n\nBSON.BSON_DATA_LONG = 18;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_DECIMAL128\n **/\n\nBSON.BSON_DATA_DECIMAL128 = 19;\n/**\n * MinKey BSON Type\n *\n * @classconstant BSON_DATA_MIN_KEY\n **/\n\nBSON.BSON_DATA_MIN_KEY = 0xff;\n/**\n * MaxKey BSON Type\n *\n * @classconstant BSON_DATA_MAX_KEY\n **/\n\nBSON.BSON_DATA_MAX_KEY = 0x7f;\n/**\n * Binary Default Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_DEFAULT\n **/\n\nBSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n/**\n * Binary Function Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_FUNCTION\n **/\n\nBSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;\n/**\n * Binary Byte Array Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY\n **/\n\nBSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\n/**\n * Binary UUID Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_UUID\n **/\n\nBSON.BSON_BINARY_SUBTYPE_UUID = 3;\n/**\n * Binary MD5 Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_MD5\n **/\n\nBSON.BSON_BINARY_SUBTYPE_MD5 = 4;\n/**\n * Binary User Defined Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED\n **/\n\nBSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128; // BSON MAX VALUES\n\nBSON.BSON_INT32_MAX = 0x7FFFFFFF;\nBSON.BSON_INT32_MIN = -0x80000000;\nBSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;\nBSON.BSON_INT64_MIN = -Math.pow(2, 63); // JS MAX PRECISE VALUES\n\nBSON.JS_INT_MAX = 0x20000000000000; // Any integer up to 2^53 can be precisely represented by a double.\n\nBSON.JS_INT_MIN = -0x20000000000000; // Any integer down to -2^53 can be precisely represented by a double.\n// Internal long versions\n\nvar JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000); // Any integer up to 2^53 can be precisely represented by a double.\n\nvar JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000); // Any integer down to -2^53 can be precisely represented by a double.\n\nmodule.exports = deserialize;","map":{"version":3,"sources":["C:/Users/SATAN/darelist/client/node_modules/bson/lib/bson/parser/deserializer.js"],"names":["readIEEE754","require","f","format","Long","Double","Timestamp","ObjectID","Symbol","Code","MinKey","MaxKey","Decimal128","Int32","DBRef","BSONRegExp","Binary","deserialize","buffer","options","isArray","index","size","length","Error","deserializeObject","evalFunctions","cacheFunctions","cacheFunctionsCrc32","fieldsAsRaw","raw","bsonRegExp","promoteBuffers","promoteLongs","promoteValues","startIndex","object","arrayIndex","elementType","i","name","toString","BSON","BSON_DATA_STRING","stringSize","BSON_DATA_OID","oid","Buffer","copy","BSON_DATA_INT","BSON_DATA_NUMBER","readDoubleLE","BSON_DATA_DATE","lowBits","highBits","Date","toNumber","BSON_DATA_BOOLEAN","BSON_DATA_OBJECT","_index","objectSize","slice","BSON_DATA_ARRAY","arrayOptions","stopIndex","n","BSON_DATA_UNDEFINED","undefined","BSON_DATA_NULL","BSON_DATA_LONG","long","lessThanOrEqual","JS_INT_MAX_LONG","greaterThanOrEqual","JS_INT_MIN_LONG","BSON_DATA_DECIMAL128","bytes","decimal128","toObject","BSON_DATA_BINARY","binarySize","totalBinarySize","subType","SUBTYPE_BYTE_ARRAY","_buffer","Uint8Array","ArrayBuffer","Array","BSON_DATA_REGEXP","source","regExpOptions","optionsArray","RegExp","join","BSON_DATA_SYMBOL","BSON_DATA_TIMESTAMP","BSON_DATA_MIN_KEY","BSON_DATA_MAX_KEY","BSON_DATA_CODE","functionString","value","hash","crc32","isolateEvalWithHash","functionCache","isolateEval","BSON_DATA_CODE_W_SCOPE","totalSize","scopeObject","scope","BSON_DATA_DBPOINTER","namespace","oidBuffer","parts","split","db","shift","collection","eval","bind","BSON_BINARY_SUBTYPE_DEFAULT","BSON_BINARY_SUBTYPE_FUNCTION","BSON_BINARY_SUBTYPE_BYTE_ARRAY","BSON_BINARY_SUBTYPE_UUID","BSON_BINARY_SUBTYPE_MD5","BSON_BINARY_SUBTYPE_USER_DEFINED","BSON_INT32_MAX","BSON_INT32_MIN","BSON_INT64_MAX","Math","pow","BSON_INT64_MIN","JS_INT_MAX","JS_INT_MIN","fromNumber","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,WAAW,GAAGC,OAAO,CAAC,iBAAD,CAAP,CAA2BD,WAA7C;AAAA,IACCE,CAAC,GAAGD,OAAO,CAAC,MAAD,CAAP,CAAgBE,MADrB;AAAA,IAECC,IAAI,GAAGH,OAAO,CAAC,SAAD,CAAP,CAAmBG,IAF3B;AAAA,IAGEC,MAAM,GAAGJ,OAAO,CAAC,WAAD,CAAP,CAAqBI,MAHhC;AAAA,IAIEC,SAAS,GAAGL,OAAO,CAAC,cAAD,CAAP,CAAwBK,SAJtC;AAAA,IAKEC,QAAQ,GAAGN,OAAO,CAAC,aAAD,CAAP,CAAuBM,QALpC;AAAA,IAMEC,MAAM,GAAGP,OAAO,CAAC,WAAD,CAAP,CAAqBO,MANhC;AAAA,IAOEC,IAAI,GAAGR,OAAO,CAAC,SAAD,CAAP,CAAmBQ,IAP5B;AAAA,IAQEC,MAAM,GAAGT,OAAO,CAAC,YAAD,CAAP,CAAsBS,MARjC;AAAA,IASEC,MAAM,GAAGV,OAAO,CAAC,YAAD,CAAP,CAAsBU,MATjC;AAAA,IAUCC,UAAU,GAAGX,OAAO,CAAC,eAAD,CAVrB;AAAA,IAWCY,KAAK,GAAGZ,OAAO,CAAC,WAAD,CAXhB;AAAA,IAYEa,KAAK,GAAGb,OAAO,CAAC,WAAD,CAAP,CAAqBa,KAZ/B;AAAA,IAaEC,UAAU,GAAGd,OAAO,CAAC,WAAD,CAAP,CAAqBc,UAbpC;AAAA,IAcEC,MAAM,GAAGf,OAAO,CAAC,WAAD,CAAP,CAAqBe,MAdhC;;AAgBA,IAAIC,WAAW,GAAG,UAASC,MAAT,EAAiBC,OAAjB,EAA0BC,OAA1B,EAAmC;AACpDD,EAAAA,OAAO,GAAGA,OAAO,IAAI,IAAX,GAAkB,EAAlB,GAAuBA,OAAjC;AACA,MAAIE,KAAK,GAAGF,OAAO,IAAIA,OAAO,CAACE,KAAnB,GAA2BF,OAAO,CAACE,KAAnC,GAA2C,CAAvD,CAFoD,CAGpD;;AACC,MAAIC,IAAI,GAAGJ,MAAM,CAACG,KAAD,CAAN,GAAgBH,MAAM,CAACG,KAAK,GAAC,CAAP,CAAN,IAAmB,CAAnC,GAAuCH,MAAM,CAACG,KAAK,GAAC,CAAP,CAAN,IAAmB,EAA1D,GAA+DH,MAAM,CAACG,KAAK,GAAC,CAAP,CAAN,IAAmB,EAA7F,CAJmD,CAMpD;;AACC,MAAGC,IAAI,GAAG,CAAP,IAAYJ,MAAM,CAACK,MAAP,GAAgBD,IAA5B,IAAqCA,IAAI,GAAGD,KAAR,GAAiBH,MAAM,CAACK,MAA/D,EAAuE;AACvE,UAAM,IAAIC,KAAJ,CAAU,sBAAV,CAAN;AACA,GATmD,CAWpD;;;AACA,MAAGN,MAAM,CAACG,KAAK,GAAGC,IAAR,GAAe,CAAhB,CAAN,IAA4B,CAA/B,EAAkC;AACjC,UAAM,IAAIE,KAAJ,CAAU,6EAAV,CAAN;AACA,GAdmD,CAgBpD;;;AACA,SAAOC,iBAAiB,CAACP,MAAD,EAASG,KAAT,EAAgBF,OAAhB,EAAyBC,OAAzB,CAAxB;AACA,CAlBD;;AAoBA,IAAIK,iBAAiB,GAAG,UAASP,MAAT,EAAiBG,KAAjB,EAAwBF,OAAxB,EAAiCC,OAAjC,EAA0C;AACjE,MAAIM,aAAa,GAAGP,OAAO,CAAC,eAAD,CAAP,IAA4B,IAA5B,GAAmC,KAAnC,GAA2CA,OAAO,CAAC,eAAD,CAAtE;AACC,MAAIQ,cAAc,GAAGR,OAAO,CAAC,gBAAD,CAAP,IAA6B,IAA7B,GAAoC,KAApC,GAA4CA,OAAO,CAAC,gBAAD,CAAxE;AACA,MAAIS,mBAAmB,GAAGT,OAAO,CAAC,qBAAD,CAAP,IAAkC,IAAlC,GAAyC,KAAzC,GAAiDA,OAAO,CAAC,qBAAD,CAAlF;AACD,MAAIU,WAAW,GAAGV,OAAO,CAAC,aAAD,CAAP,IAA0B,IAA1B,GAAiC,IAAjC,GAAwCA,OAAO,CAAC,aAAD,CAAjE,CAJiE,CAMjE;;AACA,MAAIW,GAAG,GAAGX,OAAO,CAAC,KAAD,CAAP,IAAkB,IAAlB,GAAyB,KAAzB,GAAiCA,OAAO,CAAC,KAAD,CAAlD,CAPiE,CASjE;;AACC,MAAIY,UAAU,GAAG,OAAOZ,OAAO,CAAC,YAAD,CAAd,IAAgC,SAAhC,GAA4CA,OAAO,CAAC,YAAD,CAAnD,GAAoE,KAArF,CAVgE,CAYjE;;AACA,MAAIa,cAAc,GAAGb,OAAO,CAAC,gBAAD,CAAP,IAA6B,IAA7B,GAAoC,KAApC,GAA4CA,OAAO,CAAC,gBAAD,CAAxE;AACA,MAAIc,YAAY,GAAGd,OAAO,CAAC,cAAD,CAAP,IAA2B,IAA3B,GAAkC,IAAlC,GAAyCA,OAAO,CAAC,cAAD,CAAnE;AACA,MAAIe,aAAa,GAAGf,OAAO,CAAC,eAAD,CAAP,IAA4B,IAA5B,GAAmC,IAAnC,GAA0CA,OAAO,CAAC,eAAD,CAArE,CAfiE,CAiBjE;;AACA,MAAIgB,UAAU,GAAGd,KAAjB,CAlBiE,CAoBhE;;AACA,MAAGH,MAAM,CAACK,MAAP,GAAgB,CAAnB,EAAsB,MAAM,IAAIC,KAAJ,CAAU,qCAAV,CAAN,CArB0C,CAuBjE;;AACC,MAAIF,IAAI,GAAGJ,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA/F,CAxBgE,CA0BjE;;AACC,MAAGC,IAAI,GAAG,CAAP,IAAYA,IAAI,GAAGJ,MAAM,CAACK,MAA7B,EAAqC,MAAM,IAAIC,KAAJ,CAAU,sBAAV,CAAN,CA3B2B,CA6BhE;;AACA,MAAIY,MAAM,GAAGhB,OAAO,GAAG,EAAH,GAAQ,EAA5B,CA9BgE,CA+BjE;;AACA,MAAIiB,UAAU,GAAG,CAAjB,CAhCiE,CAkChE;;AACA,SAAM,IAAN,EAAY;AACV;AACA,QAAIC,WAAW,GAAGpB,MAAM,CAACG,KAAK,EAAN,CAAxB,CAFU,CAGV;;AACA,QAAGiB,WAAW,IAAI,CAAlB,EAAqB;AACtB;AACA,KANW,CAQZ;;;AACA,QAAIC,CAAC,GAAGlB,KAAR,CATY,CAUZ;;AACA,WAAMH,MAAM,CAACqB,CAAD,CAAN,KAAc,IAAd,IAAsBA,CAAC,GAAGrB,MAAM,CAACK,MAAvC,EAA+C;AAC9CgB,MAAAA,CAAC;AACD,KAbW,CAeZ;;;AACA,QAAGA,CAAC,IAAIrB,MAAM,CAACK,MAAf,EAAuB,MAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN;AACvB,QAAIgB,IAAI,GAAGpB,OAAO,GAAGiB,UAAU,EAAb,GAAkBnB,MAAM,CAACuB,QAAP,CAAgB,MAAhB,EAAwBpB,KAAxB,EAA+BkB,CAA/B,CAApC;AAEAlB,IAAAA,KAAK,GAAGkB,CAAC,GAAG,CAAZ;;AAEA,QAAGD,WAAW,IAAII,IAAI,CAACC,gBAAvB,EAAyC;AACrC,UAAIC,UAAU,GAAG1B,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAArG;AACH,UAAGuB,UAAU,IAAI,CAAd,IAAmBA,UAAU,GAAI1B,MAAM,CAACK,MAAP,GAAgBF,KAAjD,IAA2DH,MAAM,CAACG,KAAK,GAAGuB,UAAR,GAAqB,CAAtB,CAAN,IAAkC,CAAhG,EAAmG,MAAM,IAAIpB,KAAJ,CAAU,2BAAV,CAAN;AAChGY,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAetB,MAAM,CAACuB,QAAP,CAAgB,MAAhB,EAAwBpB,KAAxB,EAA+BA,KAAK,GAAGuB,UAAR,GAAqB,CAApD,CAAf;AACAvB,MAAAA,KAAK,GAAGA,KAAK,GAAGuB,UAAhB;AACH,KALD,MAKO,IAAGN,WAAW,IAAII,IAAI,CAACG,aAAvB,EAAsC;AAC5C,UAAIC,GAAG,GAAG,IAAIC,MAAJ,CAAW,EAAX,CAAV;AACA7B,MAAAA,MAAM,CAAC8B,IAAP,CAAYF,GAAZ,EAAiB,CAAjB,EAAoBzB,KAApB,EAA2BA,KAAK,GAAG,EAAnC;AACGe,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAIjC,QAAJ,CAAauC,GAAb,CAAf;AACAzB,MAAAA,KAAK,GAAGA,KAAK,GAAG,EAAhB;AACH,KALM,MAKA,IAAGiB,WAAW,IAAII,IAAI,CAACO,aAApB,IAAqCf,aAAa,IAAI,KAAzD,EAAgE;AACtEE,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAI3B,KAAJ,CAAUK,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA9F,CAAf;AACA,KAFM,MAEA,IAAGiB,WAAW,IAAII,IAAI,CAACO,aAAvB,EAAsC;AACzCb,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAetB,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAAnG;AACH,KAFM,MAEA,IAAGiB,WAAW,IAAII,IAAI,CAACQ,gBAApB,IAAwChB,aAAa,IAAI,KAA5D,EAAmE;AACzEE,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAInC,MAAJ,CAAWa,MAAM,CAACiC,YAAP,CAAoB9B,KAApB,CAAX,CAAf;AACAA,MAAAA,KAAK,GAAGA,KAAK,GAAG,CAAhB;AACA,KAHM,MAGA,IAAGiB,WAAW,IAAII,IAAI,CAACQ,gBAAvB,EAAyC;AAC/Cd,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAetB,MAAM,CAACiC,YAAP,CAAoB9B,KAApB,CAAf;AACGA,MAAAA,KAAK,GAAGA,KAAK,GAAG,CAAhB;AACH,KAHM,MAGA,IAAGiB,WAAW,IAAII,IAAI,CAACU,cAAvB,EAAuC;AAC1C,UAAIC,OAAO,GAAGnC,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAAlG;AACA,UAAIiC,QAAQ,GAAGpC,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAAnG;AACAe,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAIe,IAAJ,CAAS,IAAInD,IAAJ,CAASiD,OAAT,EAAkBC,QAAlB,EAA4BE,QAA5B,EAAT,CAAf;AACH,KAJM,MAIA,IAAGlB,WAAW,IAAII,IAAI,CAACe,iBAAvB,EAA0C;AAChD,UAAGvC,MAAM,CAACG,KAAD,CAAN,IAAiB,CAAjB,IAAsBH,MAAM,CAACG,KAAD,CAAN,IAAiB,CAA1C,EAA6C,MAAM,IAAIG,KAAJ,CAAU,4BAAV,CAAN;AAC1CY,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAetB,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAAlC;AACH,KAHM,MAGA,IAAGiB,WAAW,IAAII,IAAI,CAACgB,gBAAvB,EAAyC;AAC/C,UAAIC,MAAM,GAAGtC,KAAb;AACG,UAAIuC,UAAU,GAAG1C,MAAM,CAACG,KAAD,CAAN,GAAgBH,MAAM,CAACG,KAAK,GAAG,CAAT,CAAN,IAAqB,CAArC,GAAyCH,MAAM,CAACG,KAAK,GAAG,CAAT,CAAN,IAAqB,EAA9D,GAAmEH,MAAM,CAACG,KAAK,GAAG,CAAT,CAAN,IAAqB,EAAzG;AACH,UAAGuC,UAAU,IAAI,CAAd,IAAmBA,UAAU,GAAI1C,MAAM,CAACK,MAAP,GAAgBF,KAApD,EAA4D,MAAM,IAAIG,KAAJ,CAAU,sCAAV,CAAN,CAHb,CAK/C;;AACA,UAAGM,GAAH,EAAQ;AACJM,QAAAA,MAAM,CAACI,IAAD,CAAN,GAAetB,MAAM,CAAC2C,KAAP,CAAaxC,KAAb,EAAoBA,KAAK,GAAGuC,UAA5B,CAAf;AACH,OAFD,MAEO;AACHxB,QAAAA,MAAM,CAACI,IAAD,CAAN,GAAef,iBAAiB,CAACP,MAAD,EAASyC,MAAT,EAAiBxC,OAAjB,EAA0B,KAA1B,CAAhC;AACH;;AAEEE,MAAAA,KAAK,GAAGA,KAAK,GAAGuC,UAAhB;AACH,KAbM,MAaA,IAAGtB,WAAW,IAAII,IAAI,CAACoB,eAAvB,EAAwC;AAC9C,UAAIH,MAAM,GAAGtC,KAAb;AACG,UAAIuC,UAAU,GAAG1C,MAAM,CAACG,KAAD,CAAN,GAAgBH,MAAM,CAACG,KAAK,GAAG,CAAT,CAAN,IAAqB,CAArC,GAAyCH,MAAM,CAACG,KAAK,GAAG,CAAT,CAAN,IAAqB,EAA9D,GAAmEH,MAAM,CAACG,KAAK,GAAG,CAAT,CAAN,IAAqB,EAAzG;AACH,UAAI0C,YAAY,GAAG5C,OAAnB,CAH8C,CAK9C;;AACA,UAAI6C,SAAS,GAAG3C,KAAK,GAAGuC,UAAxB,CAN8C,CAQ9C;;AACA,UAAG/B,WAAW,IAAIA,WAAW,CAACW,IAAD,CAA7B,EAAqC;AACpCuB,QAAAA,YAAY,GAAG,EAAf;;AACA,aAAI,IAAIE,CAAR,IAAa9C,OAAb,EAAsB4C,YAAY,CAACE,CAAD,CAAZ,GAAkB9C,OAAO,CAAC8C,CAAD,CAAzB;;AACtBF,QAAAA,YAAY,CAAC,KAAD,CAAZ,GAAsB,IAAtB;AACA;;AAEE3B,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAef,iBAAiB,CAACP,MAAD,EAASyC,MAAT,EAAiBI,YAAjB,EAA+B,IAA/B,CAAhC;AACA1C,MAAAA,KAAK,GAAGA,KAAK,GAAGuC,UAAhB;AAEH,UAAG1C,MAAM,CAACG,KAAK,GAAG,CAAT,CAAN,IAAqB,CAAxB,EAA2B,MAAM,IAAIG,KAAJ,CAAU,+BAAV,CAAN;AAC3B,UAAGH,KAAK,IAAI2C,SAAZ,EAAuB,MAAM,IAAIxC,KAAJ,CAAU,sBAAV,CAAN;AACvB,KApBM,MAoBA,IAAGc,WAAW,IAAII,IAAI,CAACwB,mBAAvB,EAA4C;AAC/C9B,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe2B,SAAf;AACH,KAFM,MAEA,IAAG7B,WAAW,IAAII,IAAI,CAAC0B,cAAvB,EAAuC;AAC7ChC,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAf;AACA,KAFM,MAEA,IAAGF,WAAW,IAAII,IAAI,CAAC2B,cAAvB,EAAuC;AAC1C;AACA,UAAIhB,OAAO,GAAGnC,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAAlG;AACA,UAAIiC,QAAQ,GAAGpC,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAAnG;AACA,UAAIiD,IAAI,GAAG,IAAIlE,IAAJ,CAASiD,OAAT,EAAkBC,QAAlB,CAAX,CAJ0C,CAK1C;;AACA,UAAGrB,YAAY,IAAIC,aAAa,IAAI,IAApC,EAA0C;AACxCE,QAAAA,MAAM,CAACI,IAAD,CAAN,GAAe8B,IAAI,CAACC,eAAL,CAAqBC,eAArB,KAAyCF,IAAI,CAACG,kBAAL,CAAwBC,eAAxB,CAAzC,GAAoFJ,IAAI,CAACd,QAAL,EAApF,GAAsGc,IAArH;AACD,OAFD,MAEO;AACLlC,QAAAA,MAAM,CAACI,IAAD,CAAN,GAAe8B,IAAf;AACD;AACJ,KAXM,MAWA,IAAGhC,WAAW,IAAII,IAAI,CAACiC,oBAAvB,EAA6C;AACnD;AACA,UAAIC,KAAK,GAAG,IAAI7B,MAAJ,CAAW,EAAX,CAAZ,CAFmD,CAGnD;;AACA7B,MAAAA,MAAM,CAAC8B,IAAP,CAAY4B,KAAZ,EAAmB,CAAnB,EAAsBvD,KAAtB,EAA6BA,KAAK,GAAG,EAArC,EAJmD,CAKnD;;AACAA,MAAAA,KAAK,GAAGA,KAAK,GAAG,EAAhB,CANmD,CAOnD;;AACA,UAAIwD,UAAU,GAAG,IAAIjE,UAAJ,CAAegE,KAAf,CAAjB,CARmD,CASnD;;AACAxC,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAeqC,UAAU,CAACC,QAAX,GAAsBD,UAAU,CAACC,QAAX,EAAtB,GAA8CD,UAA7D;AACA,KAXM,MAWA,IAAGvC,WAAW,IAAII,IAAI,CAACqC,gBAAvB,EAAyC;AAC5C,UAAIC,UAAU,GAAG9D,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAArG;AACH,UAAI4D,eAAe,GAAGD,UAAtB;AACG,UAAIE,OAAO,GAAGhE,MAAM,CAACG,KAAK,EAAN,CAApB,CAH4C,CAK/C;;AACA,UAAG2D,UAAU,GAAG,CAAhB,EAAmB,MAAM,IAAIxD,KAAJ,CAAU,yCAAV,CAAN,CAN4B,CAQ/C;;AACA,UAAGwD,UAAU,GAAG9D,MAAM,CAACK,MAAvB,EAA+B,MAAM,IAAIC,KAAJ,CAAU,4CAAV,CAAN,CATgB,CAW/C;;AACG,UAAGN,MAAM,CAAC,OAAD,CAAN,IAAmB,IAAtB,EAA4B;AAC1B;AACA,YAAGgE,OAAO,IAAIlE,MAAM,CAACmE,kBAArB,EAAyC;AACvCH,UAAAA,UAAU,GAAG9D,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAAjG;AACL,cAAG2D,UAAU,GAAG,CAAhB,EAAmB,MAAM,IAAIxD,KAAJ,CAAU,0DAAV,CAAN;AACnB,cAAGwD,UAAU,GAAIC,eAAe,GAAG,CAAnC,EAAuC,MAAM,IAAIzD,KAAJ,CAAU,4DAAV,CAAN;AACvC,cAAGwD,UAAU,GAAIC,eAAe,GAAG,CAAnC,EAAuC,MAAM,IAAIzD,KAAJ,CAAU,6DAAV,CAAN;AACnC;;AAED,YAAGQ,cAAc,IAAIE,aAArB,EAAoC;AAClCE,UAAAA,MAAM,CAACI,IAAD,CAAN,GAAetB,MAAM,CAAC2C,KAAP,CAAaxC,KAAb,EAAoBA,KAAK,GAAG2D,UAA5B,CAAf;AACD,SAFD,MAEO;AACL5C,UAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAIxB,MAAJ,CAAWE,MAAM,CAAC2C,KAAP,CAAaxC,KAAb,EAAoBA,KAAK,GAAG2D,UAA5B,CAAX,EAAoDE,OAApD,CAAf;AACD;AACF,OAdD,MAcO;AACL,YAAIE,OAAO,GAAG,OAAOC,UAAP,IAAqB,WAArB,GAAmC,IAAIA,UAAJ,CAAe,IAAIC,WAAJ,CAAgBN,UAAhB,CAAf,CAAnC,GAAiF,IAAIO,KAAJ,CAAUP,UAAV,CAA/F,CADK,CAEL;;;AACA,YAAGE,OAAO,IAAIlE,MAAM,CAACmE,kBAArB,EAAyC;AACvCH,UAAAA,UAAU,GAAG9D,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAAjG;AACL,cAAG2D,UAAU,GAAG,CAAhB,EAAmB,MAAM,IAAIxD,KAAJ,CAAU,0DAAV,CAAN;AACnB,cAAGwD,UAAU,GAAIC,eAAe,GAAG,CAAnC,EAAuC,MAAM,IAAIzD,KAAJ,CAAU,4DAAV,CAAN;AACvC,cAAGwD,UAAU,GAAIC,eAAe,GAAG,CAAnC,EAAuC,MAAM,IAAIzD,KAAJ,CAAU,6DAAV,CAAN;AACnC,SARI,CAUL;;;AACA,aAAI,IAAIe,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGyC,UAAnB,EAA+BzC,CAAC,EAAhC,EAAoC;AAClC6C,UAAAA,OAAO,CAAC7C,CAAD,CAAP,GAAarB,MAAM,CAACG,KAAK,GAAGkB,CAAT,CAAnB;AACD;;AAED,YAAGP,cAAc,IAAIE,aAArB,EAAoC;AAClCE,UAAAA,MAAM,CAACI,IAAD,CAAN,GAAe4C,OAAf;AACD,SAFD,MAEO;AACLhD,UAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAIxB,MAAJ,CAAWoE,OAAX,EAAoBF,OAApB,CAAf;AACD;AACF,OA9C2C,CAgD5C;;;AACA7D,MAAAA,KAAK,GAAGA,KAAK,GAAG2D,UAAhB;AACH,KAlDM,MAkDA,IAAG1C,WAAW,IAAII,IAAI,CAAC8C,gBAApB,IAAwCzD,UAAU,IAAI,KAAzD,EAAgE;AACtE;AACA,UAAIQ,CAAC,GAAGlB,KAAR,CAFsE,CAGtE;;AACA,aAAMH,MAAM,CAACqB,CAAD,CAAN,KAAc,IAAd,IAAsBA,CAAC,GAAGrB,MAAM,CAACK,MAAvC,EAA+C;AAC9CgB,QAAAA,CAAC;AACD,OANqE,CAOtE;;;AACA,UAAGA,CAAC,IAAIrB,MAAM,CAACK,MAAf,EAAuB,MAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN,CAR+C,CAStE;;AACA,UAAIiE,MAAM,GAAGvE,MAAM,CAACuB,QAAP,CAAgB,MAAhB,EAAwBpB,KAAxB,EAA+BkB,CAA/B,CAAb,CAVsE,CAWnE;;AACHlB,MAAAA,KAAK,GAAGkB,CAAC,GAAG,CAAZ,CAZsE,CActE;;AACA,UAAIA,CAAC,GAAGlB,KAAR,CAfsE,CAgBtE;;AACA,aAAMH,MAAM,CAACqB,CAAD,CAAN,KAAc,IAAd,IAAsBA,CAAC,GAAGrB,MAAM,CAACK,MAAvC,EAA+C;AAC9CgB,QAAAA,CAAC;AACD,OAnBqE,CAoBtE;;;AACA,UAAGA,CAAC,IAAIrB,MAAM,CAACK,MAAf,EAAuB,MAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN,CArB+C,CAsBtE;;AACA,UAAIkE,aAAa,GAAGxE,MAAM,CAACuB,QAAP,CAAgB,MAAhB,EAAwBpB,KAAxB,EAA+BkB,CAA/B,CAApB;AACAlB,MAAAA,KAAK,GAAGkB,CAAC,GAAG,CAAZ,CAxBsE,CA0BnE;;AACA,UAAIoD,YAAY,GAAG,IAAIJ,KAAJ,CAAUG,aAAa,CAACnE,MAAxB,CAAnB,CA3BmE,CA6BnE;;AACA,WAAI,IAAIgB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGmD,aAAa,CAACnE,MAAjC,EAAyCgB,CAAC,EAA1C,EAA8C;AAC5C,gBAAOmD,aAAa,CAACnD,CAAD,CAApB;AACE,eAAK,GAAL;AACEoD,YAAAA,YAAY,CAACpD,CAAD,CAAZ,GAAkB,GAAlB;AACA;;AACF,eAAK,GAAL;AACEoD,YAAAA,YAAY,CAACpD,CAAD,CAAZ,GAAkB,GAAlB;AACA;;AACF,eAAK,GAAL;AACEoD,YAAAA,YAAY,CAACpD,CAAD,CAAZ,GAAkB,GAAlB;AACA;AATJ;AAWD;;AAEDH,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAIoD,MAAJ,CAAWH,MAAX,EAAmBE,YAAY,CAACE,IAAb,CAAkB,EAAlB,CAAnB,CAAf;AACD,KA7CI,MA6CE,IAAGvD,WAAW,IAAII,IAAI,CAAC8C,gBAApB,IAAwCzD,UAAU,IAAI,IAAzD,EAA+D;AACvE;AACA,UAAIQ,CAAC,GAAGlB,KAAR,CAFuE,CAGvE;;AACA,aAAMH,MAAM,CAACqB,CAAD,CAAN,KAAc,IAAd,IAAsBA,CAAC,GAAGrB,MAAM,CAACK,MAAvC,EAA+C;AAC9CgB,QAAAA,CAAC;AACD,OANsE,CAOvE;;;AACA,UAAGA,CAAC,IAAIrB,MAAM,CAACK,MAAf,EAAuB,MAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN,CARgD,CASvE;;AACA,UAAIiE,MAAM,GAAGvE,MAAM,CAACuB,QAAP,CAAgB,MAAhB,EAAwBpB,KAAxB,EAA+BkB,CAA/B,CAAb;AACGlB,MAAAA,KAAK,GAAGkB,CAAC,GAAG,CAAZ,CAXoE,CAavE;;AACA,UAAIA,CAAC,GAAGlB,KAAR,CAduE,CAevE;;AACA,aAAMH,MAAM,CAACqB,CAAD,CAAN,KAAc,IAAd,IAAsBA,CAAC,GAAGrB,MAAM,CAACK,MAAvC,EAA+C;AAC9CgB,QAAAA,CAAC;AACD,OAlBsE,CAmBvE;;;AACA,UAAGA,CAAC,IAAIrB,MAAM,CAACK,MAAf,EAAuB,MAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN,CApBgD,CAqBvE;;AACA,UAAIkE,aAAa,GAAGxE,MAAM,CAACuB,QAAP,CAAgB,MAAhB,EAAwBpB,KAAxB,EAA+BkB,CAA/B,CAApB;AACGlB,MAAAA,KAAK,GAAGkB,CAAC,GAAG,CAAZ,CAvBoE,CAyBpE;;AACAH,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAIzB,UAAJ,CAAe0E,MAAf,EAAuBC,aAAvB,CAAf;AACH,KA3BQ,MA2BF,IAAGpD,WAAW,IAAII,IAAI,CAACoD,gBAAvB,EAAyC;AAC5C,UAAIlD,UAAU,GAAG1B,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAArG;AACH,UAAGuB,UAAU,IAAI,CAAd,IAAmBA,UAAU,GAAI1B,MAAM,CAACK,MAAP,GAAgBF,KAAjD,IAA2DH,MAAM,CAACG,KAAK,GAAGuB,UAAR,GAAqB,CAAtB,CAAN,IAAkC,CAAhG,EAAmG,MAAM,IAAIpB,KAAJ,CAAU,2BAAV,CAAN;AAChGY,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAIhC,MAAJ,CAAWU,MAAM,CAACuB,QAAP,CAAgB,MAAhB,EAAwBpB,KAAxB,EAA+BA,KAAK,GAAGuB,UAAR,GAAqB,CAApD,CAAX,CAAf;AACAvB,MAAAA,KAAK,GAAGA,KAAK,GAAGuB,UAAhB;AACH,KALM,MAKA,IAAGN,WAAW,IAAII,IAAI,CAACqD,mBAAvB,EAA4C;AAC/C,UAAI1C,OAAO,GAAGnC,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAAlG;AACA,UAAIiC,QAAQ,GAAGpC,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAAnG;AACAe,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAIlC,SAAJ,CAAc+C,OAAd,EAAuBC,QAAvB,CAAf;AACH,KAJM,MAIA,IAAGhB,WAAW,IAAII,IAAI,CAACsD,iBAAvB,EAA0C;AAC7C5D,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAI9B,MAAJ,EAAf;AACH,KAFM,MAEA,IAAG4B,WAAW,IAAII,IAAI,CAACuD,iBAAvB,EAA0C;AAC7C7D,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAI7B,MAAJ,EAAf;AACH,KAFM,MAEA,IAAG2B,WAAW,IAAII,IAAI,CAACwD,cAAvB,EAAuC;AAC1C,UAAItD,UAAU,GAAG1B,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAArG;AACH,UAAGuB,UAAU,IAAI,CAAd,IAAmBA,UAAU,GAAI1B,MAAM,CAACK,MAAP,GAAgBF,KAAjD,IAA2DH,MAAM,CAACG,KAAK,GAAGuB,UAAR,GAAqB,CAAtB,CAAN,IAAkC,CAAhG,EAAmG,MAAM,IAAIpB,KAAJ,CAAU,2BAAV,CAAN;AAChG,UAAI2E,cAAc,GAAGjF,MAAM,CAACuB,QAAP,CAAgB,MAAhB,EAAwBpB,KAAxB,EAA+BA,KAAK,GAAGuB,UAAR,GAAqB,CAApD,CAArB,CAH0C,CAK1C;;AACA,UAAGlB,aAAH,EAAkB;AAChB,YAAI0E,KAAK,GAAG,IAAZ,CADgB,CAEhB;;AACA,YAAGzE,cAAH,EAAmB;AACjB,cAAI0E,IAAI,GAAGzE,mBAAmB,GAAG0E,KAAK,CAACH,cAAD,CAAR,GAA2BA,cAAzD,CADiB,CAEjB;;AACA/D,UAAAA,MAAM,CAACI,IAAD,CAAN,GAAe+D,mBAAmB,CAACC,aAAD,EAAgBH,IAAhB,EAAsBF,cAAtB,EAAsC/D,MAAtC,CAAlC;AACD,SAJD,MAIO;AACLA,UAAAA,MAAM,CAACI,IAAD,CAAN,GAAeiE,WAAW,CAACN,cAAD,CAA1B;AACD;AACF,OAVD,MAUO;AACL/D,QAAAA,MAAM,CAACI,IAAD,CAAN,GAAgB,IAAI/B,IAAJ,CAAS0F,cAAT,CAAhB;AACD,OAlByC,CAoB1C;;;AACA9E,MAAAA,KAAK,GAAGA,KAAK,GAAGuB,UAAhB;AACH,KAtBM,MAsBA,IAAGN,WAAW,IAAII,IAAI,CAACgE,sBAAvB,EAA+C;AAClD,UAAIC,SAAS,GAAGzF,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAApG,CADkD,CAGrD;;AACA,UAAGsF,SAAS,GAAI,IAAI,CAAJ,GAAQ,CAAR,GAAY,CAA5B,EAAgC;AAC/B,cAAM,IAAInF,KAAJ,CAAU,yDAAV,CAAN;AACA,OANoD,CAQrD;;;AACG,UAAIoB,UAAU,GAAG1B,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAArG,CATkD,CAUrD;;AACA,UAAGuB,UAAU,IAAI,CAAd,IAAmBA,UAAU,GAAI1B,MAAM,CAACK,MAAP,GAAgBF,KAAjD,IAA2DH,MAAM,CAACG,KAAK,GAAGuB,UAAR,GAAqB,CAAtB,CAAN,IAAkC,CAAhG,EAAmG,MAAM,IAAIpB,KAAJ,CAAU,2BAAV,CAAN,CAX9C,CAalD;;AACA,UAAI2E,cAAc,GAAGjF,MAAM,CAACuB,QAAP,CAAgB,MAAhB,EAAwBpB,KAAxB,EAA+BA,KAAK,GAAGuB,UAAR,GAAqB,CAApD,CAArB,CAdkD,CAelD;;AACAvB,MAAAA,KAAK,GAAGA,KAAK,GAAGuB,UAAhB,CAhBkD,CAiBlD;;AACH,UAAIe,MAAM,GAAGtC,KAAb,CAlBqD,CAmBlD;;AACA,UAAIuC,UAAU,GAAG1C,MAAM,CAACG,KAAD,CAAN,GAAgBH,MAAM,CAACG,KAAK,GAAG,CAAT,CAAN,IAAqB,CAArC,GAAyCH,MAAM,CAACG,KAAK,GAAG,CAAT,CAAN,IAAqB,EAA9D,GAAmEH,MAAM,CAACG,KAAK,GAAG,CAAT,CAAN,IAAqB,EAAzG,CApBkD,CAqBlD;;AACA,UAAIuF,WAAW,GAAGnF,iBAAiB,CAACP,MAAD,EAASyC,MAAT,EAAiBxC,OAAjB,EAA0B,KAA1B,CAAnC,CAtBkD,CAuBlD;;AACAE,MAAAA,KAAK,GAAGA,KAAK,GAAGuC,UAAhB,CAxBkD,CA0BrD;;AACA,UAAG+C,SAAS,GAAI,IAAI,CAAJ,GAAQ/C,UAAR,GAAqBhB,UAArC,EAAkD;AACjD,cAAM,IAAIpB,KAAJ,CAAU,uDAAV,CAAN;AACA,OA7BoD,CA+BrD;;;AACA,UAAGmF,SAAS,GAAI,IAAI,CAAJ,GAAQ/C,UAAR,GAAqBhB,UAArC,EAAkD;AACjD,cAAM,IAAIpB,KAAJ,CAAU,0DAAV,CAAN;AACA,OAlCoD,CAoClD;;;AACA,UAAGE,aAAH,EAAkB;AAChB;AACA,YAAI0E,KAAK,GAAG,IAAZ,CAFgB,CAGhB;;AACA,YAAGzE,cAAH,EAAmB;AACjB,cAAI0E,IAAI,GAAGzE,mBAAmB,GAAG0E,KAAK,CAACH,cAAD,CAAR,GAA2BA,cAAzD,CADiB,CAEjB;;AACA/D,UAAAA,MAAM,CAACI,IAAD,CAAN,GAAe+D,mBAAmB,CAACC,aAAD,EAAgBH,IAAhB,EAAsBF,cAAtB,EAAsC/D,MAAtC,CAAlC;AACD,SAJD,MAIO;AACLA,UAAAA,MAAM,CAACI,IAAD,CAAN,GAAeiE,WAAW,CAACN,cAAD,CAA1B;AACD;;AAED/D,QAAAA,MAAM,CAACI,IAAD,CAAN,CAAaqE,KAAb,GAAqBD,WAArB;AACD,OAbD,MAaO;AACLxE,QAAAA,MAAM,CAACI,IAAD,CAAN,GAAgB,IAAI/B,IAAJ,CAAS0F,cAAT,EAAyBS,WAAzB,CAAhB;AACD;AACJ,KArDM,MAqDA,IAAGtE,WAAW,IAAIwE,mBAAlB,EAAuC;AAC7C;AACG,UAAIlE,UAAU,GAAG1B,MAAM,CAACG,KAAK,EAAN,CAAN,GAAkBH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,CAArC,GAAyCH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAA5D,GAAiEH,MAAM,CAACG,KAAK,EAAN,CAAN,IAAmB,EAArG,CAF0C,CAG7C;;AACA,UAAGuB,UAAU,IAAI,CAAd,IAAmBA,UAAU,GAAI1B,MAAM,CAACK,MAAP,GAAgBF,KAAjD,IAA2DH,MAAM,CAACG,KAAK,GAAGuB,UAAR,GAAqB,CAAtB,CAAN,IAAkC,CAAhG,EAAmG,MAAM,IAAIpB,KAAJ,CAAU,2BAAV,CAAN,CAJtD,CAK7C;;AACG,UAAIuF,SAAS,GAAG7F,MAAM,CAACuB,QAAP,CAAgB,MAAhB,EAAwBpB,KAAxB,EAA+BA,KAAK,GAAGuB,UAAR,GAAqB,CAApD,CAAhB,CAN0C,CAO7C;;AACGvB,MAAAA,KAAK,GAAGA,KAAK,GAAGuB,UAAhB,CAR0C,CAU7C;;AACA,UAAIoE,SAAS,GAAG,IAAIjE,MAAJ,CAAW,EAAX,CAAhB;AACA7B,MAAAA,MAAM,CAAC8B,IAAP,CAAYgE,SAAZ,EAAuB,CAAvB,EAA0B3F,KAA1B,EAAiCA,KAAK,GAAG,EAAzC;AACG,UAAIyB,GAAG,GAAG,IAAIvC,QAAJ,CAAayG,SAAb,CAAV,CAb0C,CAe7C;;AACA3F,MAAAA,KAAK,GAAGA,KAAK,GAAG,EAAhB,CAhB6C,CAkB7C;;AACA,UAAI4F,KAAK,GAAGF,SAAS,CAACG,KAAV,CAAgB,GAAhB,CAAZ;AACA,UAAIC,EAAE,GAAGF,KAAK,CAACG,KAAN,EAAT;AACA,UAAIC,UAAU,GAAGJ,KAAK,CAACpB,IAAN,CAAW,GAAX,CAAjB,CArB6C,CAsB7C;;AACAzD,MAAAA,MAAM,CAACI,IAAD,CAAN,GAAe,IAAI1B,KAAJ,CAAUuG,UAAV,EAAsBvE,GAAtB,EAA2BqE,EAA3B,CAAf;AACE,KAxBI,MAwBE;AACR,YAAM,IAAI3F,KAAJ,CAAU,gCAAgCc,WAAW,CAACG,QAAZ,CAAqB,EAArB,CAAhC,GAA2D,mBAA3D,GAAiFD,IAAjF,GAAwF,0CAAlG,CAAN;AACA;AACA,GA3X+D,CA6XjE;;;AACA,MAAGlB,IAAI,IAAKD,KAAK,GAAGc,UAApB,EAAiC;AAChC,QAAGf,OAAH,EAAY,MAAM,IAAII,KAAJ,CAAU,oBAAV,CAAN;AACZ,UAAM,IAAIA,KAAJ,CAAU,qBAAV,CAAN;AACA,GAjYgE,CAmYhE;;;AACA,MAAGY,MAAM,CAAC,KAAD,CAAN,IAAiB,IAApB,EAA0BA,MAAM,GAAG,IAAItB,KAAJ,CAAUsB,MAAM,CAAC,MAAD,CAAhB,EAA0BA,MAAM,CAAC,KAAD,CAAhC,EAAyCA,MAAM,CAAC,KAAD,CAA/C,CAAT;AAC1B,SAAOA,MAAP;AACD,CAtYD;AAwYA;;;;;;;;AAMA,IAAImE,mBAAmB,GAAG,UAASC,aAAT,EAAwBH,IAAxB,EAA8BF,cAA9B,EAA8C/D,MAA9C,EAAsD;AAC9E;AACA,MAAIgE,KAAK,GAAG,IAAZ,CAF8E,CAI9E;;AACA,MAAGI,aAAa,CAACH,IAAD,CAAb,IAAuB,IAA1B,EAAgC;AAC9BiB,IAAAA,IAAI,CAAC,aAAanB,cAAd,CAAJ;AACAK,IAAAA,aAAa,CAACH,IAAD,CAAb,GAAsBD,KAAtB;AACD,GAR6E,CAS9E;;;AACA,SAAOI,aAAa,CAACH,IAAD,CAAb,CAAoBkB,IAApB,CAAyBnF,MAAzB,CAAP;AACD,CAXD;AAaA;;;;;;;;AAMA,IAAIqE,WAAW,GAAG,UAASN,cAAT,EAAyB;AACzC;AACA,MAAIC,KAAK,GAAG,IAAZ,CAFyC,CAGzC;;AACAkB,EAAAA,IAAI,CAAC,aAAanB,cAAd,CAAJ;AACA,SAAOC,KAAP;AACD,CAND;;AAQA,IAAI1D,IAAI,GAAG,EAAX;AAEA;;;;;;;AAMA,IAAI8D,aAAa,GAAG9D,IAAI,CAAC8D,aAAL,GAAqB,EAAzC;AAEA;;;;;;AAKA9D,IAAI,CAACQ,gBAAL,GAAwB,CAAxB;AACA;;;;;;AAKAR,IAAI,CAACC,gBAAL,GAAwB,CAAxB;AACA;;;;;;AAKAD,IAAI,CAACgB,gBAAL,GAAwB,CAAxB;AACA;;;;;;AAKAhB,IAAI,CAACoB,eAAL,GAAuB,CAAvB;AACA;;;;;;AAKApB,IAAI,CAACqC,gBAAL,GAAwB,CAAxB;AACA;;;;;;AAKArC,IAAI,CAACwB,mBAAL,GAA2B,CAA3B;AACA;;;;;;AAKAxB,IAAI,CAACG,aAAL,GAAqB,CAArB;AACA;;;;;;AAKAH,IAAI,CAACe,iBAAL,GAAyB,CAAzB;AACA;;;;;;AAKAf,IAAI,CAACU,cAAL,GAAsB,CAAtB;AACA;;;;;;AAKAV,IAAI,CAAC0B,cAAL,GAAsB,EAAtB;AACA;;;;;;AAKA1B,IAAI,CAAC8C,gBAAL,GAAwB,EAAxB;AACA;;;;;;AAKA9C,IAAI,CAACoE,mBAAL,GAA2B,EAA3B;AACA;;;;;;AAKApE,IAAI,CAACwD,cAAL,GAAsB,EAAtB;AACA;;;;;;AAKAxD,IAAI,CAACoD,gBAAL,GAAwB,EAAxB;AACA;;;;;;AAKApD,IAAI,CAACgE,sBAAL,GAA8B,EAA9B;AACA;;;;;;AAKAhE,IAAI,CAACO,aAAL,GAAqB,EAArB;AACA;;;;;;AAKAP,IAAI,CAACqD,mBAAL,GAA2B,EAA3B;AACA;;;;;;AAKArD,IAAI,CAAC2B,cAAL,GAAsB,EAAtB;AACA;;;;;;AAKA3B,IAAI,CAACiC,oBAAL,GAA4B,EAA5B;AACA;;;;;;AAKAjC,IAAI,CAACsD,iBAAL,GAAyB,IAAzB;AACA;;;;;;AAKAtD,IAAI,CAACuD,iBAAL,GAAyB,IAAzB;AAEA;;;;;;AAKAvD,IAAI,CAAC8E,2BAAL,GAAmC,CAAnC;AACA;;;;;;AAKA9E,IAAI,CAAC+E,4BAAL,GAAoC,CAApC;AACA;;;;;;AAKA/E,IAAI,CAACgF,8BAAL,GAAsC,CAAtC;AACA;;;;;;AAKAhF,IAAI,CAACiF,wBAAL,GAAgC,CAAhC;AACA;;;;;;AAKAjF,IAAI,CAACkF,uBAAL,GAA+B,CAA/B;AACA;;;;;;AAKAlF,IAAI,CAACmF,gCAAL,GAAwC,GAAxC,C,CAEA;;AACAnF,IAAI,CAACoF,cAAL,GAAsB,UAAtB;AACApF,IAAI,CAACqF,cAAL,GAAsB,CAAC,UAAvB;AAEArF,IAAI,CAACsF,cAAL,GAAsBC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAAxC;AACAxF,IAAI,CAACyF,cAAL,GAAsB,CAACF,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAvB,C,CAEA;;AACAxF,IAAI,CAAC0F,UAAL,GAAkB,gBAAlB,C,CAAqC;;AACrC1F,IAAI,CAAC2F,UAAL,GAAkB,CAAC,gBAAnB,C,CAAsC;AAEtC;;AACA,IAAI7D,eAAe,GAAGpE,IAAI,CAACkI,UAAL,CAAgB,gBAAhB,CAAtB,C,CAA0D;;AAC1D,IAAI5D,eAAe,GAAGtE,IAAI,CAACkI,UAAL,CAAgB,CAAC,gBAAjB,CAAtB,C,CAA2D;;AAE3DC,MAAM,CAACC,OAAP,GAAiBvH,WAAjB","sourcesContent":["\"use strict\"\n\nvar readIEEE754 = require('../float_parser').readIEEE754,\n\tf = require('util').format,\n\tLong = require('../long').Long,\n  Double = require('../double').Double,\n  Timestamp = require('../timestamp').Timestamp,\n  ObjectID = require('../objectid').ObjectID,\n  Symbol = require('../symbol').Symbol,\n  Code = require('../code').Code,\n  MinKey = require('../min_key').MinKey,\n  MaxKey = require('../max_key').MaxKey,\n\tDecimal128 = require('../decimal128'),\n\tInt32 = require('../int_32'),\n  DBRef = require('../db_ref').DBRef,\n  BSONRegExp = require('../regexp').BSONRegExp,\n  Binary = require('../binary').Binary;\n\nvar deserialize = function(buffer, options, isArray) {\n\toptions = options == null ? {} : options;\n\tvar index = options && options.index ? options.index : 0;\n\t// Read the document size\n  var size = buffer[index] | buffer[index+1] << 8 | buffer[index+2] << 16 | buffer[index+3] << 24;\n\n\t// Ensure buffer is valid size\n  if(size < 5 || buffer.length < size || (size + index) > buffer.length) {\n\t\tthrow new Error(\"corrupt bson message\");\n\t}\n\n\t// Illegal end value\n\tif(buffer[index + size - 1] != 0) {\n\t\tthrow new Error(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n\t}\n\n\t// Start deserializtion\n\treturn deserializeObject(buffer, index, options, isArray);\n}\n\nvar deserializeObject = function(buffer, index, options, isArray) {\n\tvar evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];\n  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];\n  var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];\n\tvar fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\n\n\t// Return raw bson buffer instead of parsing it\n\tvar raw = options['raw'] == null ? false : options['raw'];\n\n\t// Return BSONRegExp objects instead of native regular expressions\n  var bsonRegExp = typeof options['bsonRegExp'] == 'boolean' ? options['bsonRegExp'] : false;\n\n\t// Controls the promotion of values vs wrapper classes\n\tvar promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];\n\tvar promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];\n\tvar promoteValues = options['promoteValues'] == null ? true : options['promoteValues'];\n\n\t// Set the start index\n\tvar startIndex = index;\n\n  // Validate that we have at least 4 bytes of buffer\n  if(buffer.length < 5) throw new Error(\"corrupt bson message < 5 bytes long\");\n\n\t// Read the document size\n  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\n\t// Ensure buffer is valid size\n  if(size < 5 || size > buffer.length) throw new Error(\"corrupt bson message\");\n\n  // Create holding object\n  var object = isArray ? [] : {};\n\t// Used for arrays to skip having to perform utf8 decoding\n\tvar arrayIndex = 0;\n\n  // While we have more left data left keep parsing\n  while(true) {\n    // Read the type\n    var elementType = buffer[index++];\n    // If we get a zero it's the last byte, exit\n    if(elementType == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the start search index\n\t\tvar i = index;\n\t\t// Locate the end of the c string\n\t\twhile(buffer[i] !== 0x00 && i < buffer.length) {\n\t\t\ti++\n\t\t}\n\n\t\t// If are at the end of the buffer there is a problem with the document\n\t\tif(i >= buffer.length) throw new Error(\"Bad BSON Document: illegal CString\")\n\t\tvar name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i);\n\n\t\tindex = i + 1;\n\n\t\tif(elementType == BSON.BSON_DATA_STRING) {\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\t\t\tif(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error(\"bad string length in bson\");\n      object[name] = buffer.toString('utf8', index, index + stringSize - 1);\n      index = index + stringSize;\n\t\t} else if(elementType == BSON.BSON_DATA_OID) {\n\t\t\tvar oid = new Buffer(12);\n\t\t\tbuffer.copy(oid, 0, index, index + 12);\n      object[name] = new ObjectID(oid);\n      index = index + 12;\n\t\t} else if(elementType == BSON.BSON_DATA_INT && promoteValues == false) {\n\t\t\tobject[name] = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);\n\t\t} else if(elementType == BSON.BSON_DATA_INT) {\n      object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\t\t} else if(elementType == BSON.BSON_DATA_NUMBER && promoteValues == false) {\n\t\t\tobject[name] = new Double(buffer.readDoubleLE(index));\n\t\t\tindex = index + 8;\n\t\t} else if(elementType == BSON.BSON_DATA_NUMBER) {\n\t\t\tobject[name] = buffer.readDoubleLE(index);\n      index = index + 8;\n\t\t} else if(elementType == BSON.BSON_DATA_DATE) {\n      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      object[name] = new Date(new Long(lowBits, highBits).toNumber());\n\t\t} else if(elementType == BSON.BSON_DATA_BOOLEAN) {\n\t\t\tif(buffer[index] != 0 && buffer[index] != 1) throw new Error('illegal boolean type value');\n      object[name] = buffer[index++] == 1;\n\t\t} else if(elementType == BSON.BSON_DATA_OBJECT) {\n\t\t\tvar _index = index;\n      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n\t\t\tif(objectSize <= 0 || objectSize > (buffer.length - index)) throw new Error(\"bad embedded document length in bson\");\n\n\t\t\t// We have a raw value\n\t\t\tif(raw) {\n\t      object[name] = buffer.slice(index, index + objectSize);\n\t\t\t} else {\n\t      object[name] = deserializeObject(buffer, _index, options, false);\n\t\t\t}\n\n      index = index + objectSize;\n\t\t} else if(elementType == BSON.BSON_DATA_ARRAY) {\n\t\t\tvar _index = index;\n      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n\t\t\tvar arrayOptions = options;\n\n\t\t\t// Stop index\n\t\t\tvar stopIndex = index + objectSize;\n\n\t\t\t// All elements of array to be returned as raw bson\n\t\t\tif(fieldsAsRaw && fieldsAsRaw[name]) {\n\t\t\t\tarrayOptions = {};\n\t\t\t\tfor(var n in options) arrayOptions[n] = options[n];\n\t\t\t\tarrayOptions['raw'] = true;\n\t\t\t}\n\n      object[name] = deserializeObject(buffer, _index, arrayOptions, true);\n      index = index + objectSize;\n\n\t\t\tif(buffer[index - 1] != 0) throw new Error('invalid array terminator byte');\n\t\t\tif(index != stopIndex) throw new Error('corrupted array bson');\n\t\t} else if(elementType == BSON.BSON_DATA_UNDEFINED) {\n      object[name] = undefined;\n\t\t} else if(elementType == BSON.BSON_DATA_NULL) {\n\t\t\tobject[name] = null;\n\t\t} else if(elementType == BSON.BSON_DATA_LONG) {\n      // Unpack the low and high bits\n      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var long = new Long(lowBits, highBits);\n      // Promote the long if possible\n      if(promoteLongs && promoteValues == true) {\n        object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n      } else {\n        object[name] = long;\n      }\n\t\t} else if(elementType == BSON.BSON_DATA_DECIMAL128) {\n\t\t\t// Buffer to contain the decimal bytes\n\t\t\tvar bytes = new Buffer(16);\n\t\t\t// Copy the next 16 bytes into the bytes buffer\n\t\t\tbuffer.copy(bytes, 0, index, index + 16);\n\t\t\t// Update index\n\t\t\tindex = index + 16;\n\t\t\t// Assign the new Decimal128 value\n\t\t\tvar decimal128 = new Decimal128(bytes);\n\t\t\t// If we have an alternative mapper use that\n\t\t\tobject[name] = decimal128.toObject ? decimal128.toObject() : decimal128;\n\t\t} else if(elementType == BSON.BSON_DATA_BINARY) {\n      var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\t\t\tvar totalBinarySize = binarySize;\n      var subType = buffer[index++];\n\n\t\t\t// Did we have a negative binary size, throw\n\t\t\tif(binarySize < 0) throw new Error('Negative binary type element size found');\n\n\t\t\t// Is the length longer than the document\n\t\t\tif(binarySize > buffer.length) throw new Error('Binary type size larger than document size');\n\n\t\t\t// Decode as raw Buffer object if options specifies it\n      if(buffer['slice'] != null) {\n        // If we have subtype 2 skip the 4 bytes for the size\n        if(subType == Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\t\t\t\t\tif(binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');\n\t\t\t\t\tif(binarySize > (totalBinarySize - 4)) throw new Error('Binary type with subtype 0x02 contains to long binary size');\n\t\t\t\t\tif(binarySize < (totalBinarySize - 4)) throw new Error('Binary type with subtype 0x02 contains to short binary size');\n        }\n\n        if(promoteBuffers && promoteValues) {\n          object[name] = buffer.slice(index, index + binarySize);\n        } else {\n          object[name] = new Binary(buffer.slice(index, index + binarySize), subType);\n        }\n      } else {\n        var _buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);\n        // If we have subtype 2 skip the 4 bytes for the size\n        if(subType == Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\t\t\t\t\tif(binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');\n\t\t\t\t\tif(binarySize > (totalBinarySize - 4)) throw new Error('Binary type with subtype 0x02 contains to long binary size');\n\t\t\t\t\tif(binarySize < (totalBinarySize - 4)) throw new Error('Binary type with subtype 0x02 contains to short binary size');\n        }\n\n        // Copy the data\n        for(var i = 0; i < binarySize; i++) {\n          _buffer[i] = buffer[index + i];\n        }\n\n        if(promoteBuffers && promoteValues) {\n          object[name] = _buffer;\n        } else {\n          object[name] = new Binary(_buffer, subType);\n        }\n      }\n\n      // Update the index\n      index = index + binarySize;\n\t\t} else if(elementType == BSON.BSON_DATA_REGEXP && bsonRegExp == false) {\n\t\t\t// Get the start search index\n\t\t\tvar i = index;\n\t\t\t// Locate the end of the c string\n\t\t\twhile(buffer[i] !== 0x00 && i < buffer.length) {\n\t\t\t\ti++\n\t\t\t}\n\t\t\t// If are at the end of the buffer there is a problem with the document\n\t\t\tif(i >= buffer.length) throw new Error(\"Bad BSON Document: illegal CString\")\n\t\t\t// Return the C string\n\t\t\tvar source = buffer.toString('utf8', index, i);\n      // Create the regexp\n\t\t\tindex = i + 1;\n\n\t\t\t// Get the start search index\n\t\t\tvar i = index;\n\t\t\t// Locate the end of the c string\n\t\t\twhile(buffer[i] !== 0x00 && i < buffer.length) {\n\t\t\t\ti++\n\t\t\t}\n\t\t\t// If are at the end of the buffer there is a problem with the document\n\t\t\tif(i >= buffer.length) throw new Error(\"Bad BSON Document: illegal CString\")\n\t\t\t// Return the C string\n\t\t\tvar regExpOptions = buffer.toString('utf8', index, i);\n\t\t\tindex = i + 1;\n\n      // For each option add the corresponding one for javascript\n      var optionsArray = new Array(regExpOptions.length);\n\n      // Parse options\n      for(var i = 0; i < regExpOptions.length; i++) {\n        switch(regExpOptions[i]) {\n          case 'm':\n            optionsArray[i] = 'm';\n            break;\n          case 's':\n            optionsArray[i] = 'g';\n            break;\n          case 'i':\n            optionsArray[i] = 'i';\n            break;\n        }\n      }\n\n      object[name] = new RegExp(source, optionsArray.join(''));\n    } else if(elementType == BSON.BSON_DATA_REGEXP && bsonRegExp == true) {\n\t\t\t// Get the start search index\n\t\t\tvar i = index;\n\t\t\t// Locate the end of the c string\n\t\t\twhile(buffer[i] !== 0x00 && i < buffer.length) {\n\t\t\t\ti++\n\t\t\t}\n\t\t\t// If are at the end of the buffer there is a problem with the document\n\t\t\tif(i >= buffer.length) throw new Error(\"Bad BSON Document: illegal CString\")\n\t\t\t// Return the C string\n\t\t\tvar source = buffer.toString('utf8', index, i);\n      index = i + 1;\n\n\t\t\t// Get the start search index\n\t\t\tvar i = index;\n\t\t\t// Locate the end of the c string\n\t\t\twhile(buffer[i] !== 0x00 && i < buffer.length) {\n\t\t\t\ti++\n\t\t\t}\n\t\t\t// If are at the end of the buffer there is a problem with the document\n\t\t\tif(i >= buffer.length) throw new Error(\"Bad BSON Document: illegal CString\")\n\t\t\t// Return the C string\n\t\t\tvar regExpOptions = buffer.toString('utf8', index, i);\n      index = i + 1;\n\n      // Set the object\n      object[name] = new BSONRegExp(source, regExpOptions);\n\t\t} else if(elementType == BSON.BSON_DATA_SYMBOL) {\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\t\t\tif(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error(\"bad string length in bson\");\n      object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));\n      index = index + stringSize;\n\t\t} else if(elementType == BSON.BSON_DATA_TIMESTAMP) {\n      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      object[name] = new Timestamp(lowBits, highBits);\n\t\t} else if(elementType == BSON.BSON_DATA_MIN_KEY) {\n      object[name] = new MinKey();\n\t\t} else if(elementType == BSON.BSON_DATA_MAX_KEY) {\n      object[name] = new MaxKey();\n\t\t} else if(elementType == BSON.BSON_DATA_CODE) {\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\t\t\tif(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error(\"bad string length in bson\");\n      var functionString = buffer.toString('utf8', index, index + stringSize - 1);\n\n      // If we are evaluating the functions\n      if(evalFunctions) {\n        var value = null;\n        // If we have cache enabled let's look for the md5 of the function in the cache\n        if(cacheFunctions) {\n          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\n        } else {\n          object[name] = isolateEval(functionString);\n        }\n      } else {\n        object[name]  = new Code(functionString);\n      }\n\n      // Update parse index position\n      index = index + stringSize;\n\t\t} else if(elementType == BSON.BSON_DATA_CODE_W_SCOPE) {\n      var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\n\t\t\t// Element cannot be shorter than totalSize + stringSize + documentSize + terminator\n\t\t\tif(totalSize < (4 + 4 + 4 + 1)) {\n\t\t\t\tthrow new Error(\"code_w_scope total size shorter minimum expected length\");\n\t\t\t}\n\n\t\t\t// Get the code string size\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\t\t\t// Check if we have a valid string\n\t\t\tif(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error(\"bad string length in bson\");\n\n      // Javascript function\n      var functionString = buffer.toString('utf8', index, index + stringSize - 1);\n      // Update parse index position\n      index = index + stringSize;\n      // Parse the element\n\t\t\tvar _index = index;\n      // Decode the size of the object document\n      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      // Decode the scope object\n      var scopeObject = deserializeObject(buffer, _index, options, false);\n      // Adjust the index\n      index = index + objectSize;\n\n\t\t\t// Check if field length is to short\n\t\t\tif(totalSize < (4 + 4 + objectSize + stringSize)) {\n\t\t\t\tthrow new Error('code_w_scope total size is to short, truncating scope');\n\t\t\t}\n\n\t\t\t// Check if totalSize field is to long\n\t\t\tif(totalSize > (4 + 4 + objectSize + stringSize)) {\n\t\t\t\tthrow new Error('code_w_scope total size is to long, clips outer document');\n\t\t\t}\n\n      // If we are evaluating the functions\n      if(evalFunctions) {\n        // Contains the value we are going to set\n        var value = null;\n        // If we have cache enabled let's look for the md5 of the function in the cache\n        if(cacheFunctions) {\n          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\n        } else {\n          object[name] = isolateEval(functionString);\n        }\n\n        object[name].scope = scopeObject;\n      } else {\n        object[name]  = new Code(functionString, scopeObject);\n      }\n\t\t} else if(elementType == BSON_DATA_DBPOINTER) {\n\t\t\t// Get the code string size\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n\t\t\t// Check if we have a valid string\n\t\t\tif(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error(\"bad string length in bson\");\n\t\t\t// Namespace\n      var namespace = buffer.toString('utf8', index, index + stringSize - 1);\n\t\t\t// Update parse index position\n      index = index + stringSize;\n\n\t\t\t// Read the oid\n\t\t\tvar oidBuffer = new Buffer(12);\n\t\t\tbuffer.copy(oidBuffer, 0, index, index + 12);\n      var oid = new ObjectID(oidBuffer);\n\n\t\t\t// Update the index\n\t\t\tindex = index + 12;\n\n\t\t\t// Split the namespace\n\t\t\tvar parts = namespace.split('.');\n\t\t\tvar db = parts.shift();\n\t\t\tvar collection = parts.join('.');\n\t\t\t// Upgrade to DBRef type\n\t\t\tobject[name] = new DBRef(collection, oid, db);\n    } else {\n\t\t\tthrow new Error(\"Detected unknown BSON type \" + elementType.toString(16) + \" for fieldname \\\"\" + name + \"\\\", are you using the latest BSON parser\");\n\t\t}\n  }\n\n\t// Check if the deserialization was against a valid array/object\n\tif(size != (index - startIndex)) {\n\t\tif(isArray) throw new Error('corrupt array bson');\n\t\tthrow new Error('corrupt object bson');\n\t}\n\n  // Check if we have a db ref object\n  if(object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);\n  return object;\n}\n\n/**\n * Ensure eval is isolated.\n *\n * @ignore\n * @api private\n */\nvar isolateEvalWithHash = function(functionCache, hash, functionString, object) {\n  // Contains the value we are going to set\n  var value = null;\n\n  // Check for cache hit, eval if missing and return cached function\n  if(functionCache[hash] == null) {\n    eval(\"value = \" + functionString);\n    functionCache[hash] = value;\n  }\n  // Set the object\n  return functionCache[hash].bind(object);\n}\n\n/**\n * Ensure eval is isolated.\n *\n * @ignore\n * @api private\n */\nvar isolateEval = function(functionString) {\n  // Contains the value we are going to set\n  var value = null;\n  // Eval the function\n  eval(\"value = \" + functionString);\n  return value;\n}\n\nvar BSON = {};\n\n/**\n * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5\n *\n * @ignore\n * @api private\n */\nvar functionCache = BSON.functionCache = {};\n\n/**\n * Number BSON Type\n *\n * @classconstant BSON_DATA_NUMBER\n **/\nBSON.BSON_DATA_NUMBER = 1;\n/**\n * String BSON Type\n *\n * @classconstant BSON_DATA_STRING\n **/\nBSON.BSON_DATA_STRING = 2;\n/**\n * Object BSON Type\n *\n * @classconstant BSON_DATA_OBJECT\n **/\nBSON.BSON_DATA_OBJECT = 3;\n/**\n * Array BSON Type\n *\n * @classconstant BSON_DATA_ARRAY\n **/\nBSON.BSON_DATA_ARRAY = 4;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_BINARY\n **/\nBSON.BSON_DATA_BINARY = 5;\n/**\n * Binary BSON Type\n *\n * @classconstant BSON_DATA_UNDEFINED\n **/\nBSON.BSON_DATA_UNDEFINED = 6;\n/**\n * ObjectID BSON Type\n *\n * @classconstant BSON_DATA_OID\n **/\nBSON.BSON_DATA_OID = 7;\n/**\n * Boolean BSON Type\n *\n * @classconstant BSON_DATA_BOOLEAN\n **/\nBSON.BSON_DATA_BOOLEAN = 8;\n/**\n * Date BSON Type\n *\n * @classconstant BSON_DATA_DATE\n **/\nBSON.BSON_DATA_DATE = 9;\n/**\n * null BSON Type\n *\n * @classconstant BSON_DATA_NULL\n **/\nBSON.BSON_DATA_NULL = 10;\n/**\n * RegExp BSON Type\n *\n * @classconstant BSON_DATA_REGEXP\n **/\nBSON.BSON_DATA_REGEXP = 11;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_DBPOINTER\n **/\nBSON.BSON_DATA_DBPOINTER = 12;\n/**\n * Code BSON Type\n *\n * @classconstant BSON_DATA_CODE\n **/\nBSON.BSON_DATA_CODE = 13;\n/**\n * Symbol BSON Type\n *\n * @classconstant BSON_DATA_SYMBOL\n **/\nBSON.BSON_DATA_SYMBOL = 14;\n/**\n * Code with Scope BSON Type\n *\n * @classconstant BSON_DATA_CODE_W_SCOPE\n **/\nBSON.BSON_DATA_CODE_W_SCOPE = 15;\n/**\n * 32 bit Integer BSON Type\n *\n * @classconstant BSON_DATA_INT\n **/\nBSON.BSON_DATA_INT = 16;\n/**\n * Timestamp BSON Type\n *\n * @classconstant BSON_DATA_TIMESTAMP\n **/\nBSON.BSON_DATA_TIMESTAMP = 17;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_LONG\n **/\nBSON.BSON_DATA_LONG = 18;\n/**\n * Long BSON Type\n *\n * @classconstant BSON_DATA_DECIMAL128\n **/\nBSON.BSON_DATA_DECIMAL128 = 19;\n/**\n * MinKey BSON Type\n *\n * @classconstant BSON_DATA_MIN_KEY\n **/\nBSON.BSON_DATA_MIN_KEY = 0xff;\n/**\n * MaxKey BSON Type\n *\n * @classconstant BSON_DATA_MAX_KEY\n **/\nBSON.BSON_DATA_MAX_KEY = 0x7f;\n\n/**\n * Binary Default Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_DEFAULT\n **/\nBSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n/**\n * Binary Function Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_FUNCTION\n **/\nBSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;\n/**\n * Binary Byte Array Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY\n **/\nBSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\n/**\n * Binary UUID Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_UUID\n **/\nBSON.BSON_BINARY_SUBTYPE_UUID = 3;\n/**\n * Binary MD5 Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_MD5\n **/\nBSON.BSON_BINARY_SUBTYPE_MD5 = 4;\n/**\n * Binary User Defined Type\n *\n * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED\n **/\nBSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;\n\n// BSON MAX VALUES\nBSON.BSON_INT32_MAX = 0x7FFFFFFF;\nBSON.BSON_INT32_MIN = -0x80000000;\n\nBSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;\nBSON.BSON_INT64_MIN = -Math.pow(2, 63);\n\n// JS MAX PRECISE VALUES\nBSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.\nBSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.\n\n// Internal long versions\nvar JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.\nvar JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.\n\nmodule.exports = deserialize\n"]},"metadata":{},"sourceType":"script"}