{"ast":null,"code":"/*!\n * Module dependencies.\n */\nvar StrictModeError = require('./error/strict');\n\nvar Types = require('./schema/index');\n\nvar utils = require('./utils');\n\nvar ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n/**\n * Handles internal casting for queries\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} options the query options\n * @api private\n */\n\nmodule.exports = function cast(schema, obj, options) {\n  var paths = Object.keys(obj),\n      i = paths.length,\n      _keys,\n      any$conditionals,\n      schematype,\n      nested,\n      path,\n      type,\n      val;\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      var k = val.length;\n\n      while (k--) {\n        val[k] = cast(schema, val[k]);\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        var split = path.split('.'),\n            j = split.length,\n            pathFirstHalf,\n            pathLastHalf,\n            remainingConds; // Find the part of the var path that is a path of the Schema\n\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n\n          if (schematype) {\n            break;\n          }\n        } // If a substring of the input path resolves to an actual real path...\n\n\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n\n          continue;\n        }\n\n        if (utils.isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n          var geo = '';\n\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            var numbertype = new Types.Number('__QueryCasting__');\n            var value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(val.$maxDistance);\n            }\n\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(val.$minDistance);\n            }\n\n            if (geo === '$within') {\n              var withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within paramater: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' && typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') && value.$geometry && typeof value.$geometry.type === 'string' && Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(value.$maxDistance);\n              }\n\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(value.$minDistance);\n              }\n\n              if (utils.isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (utils.isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({\n                    virtuals: false\n                  });\n                }\n\n                var geoWithinType = value.$geometry.type;\n\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' + geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center || value.$centerSphere;\n\n                if (utils.isMongooseObject(value)) {\n                  value = value.toObject({\n                    virtuals: false\n                  });\n                }\n              }\n            }\n\n            _cast(value, numbertype);\n          }\n        }\n\n        if (options && options.upsert && options.strict) {\n          if (options.strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema, strict mode is `true`, and upsert is `true`.');\n        }\n      } else if (val === null || val === undefined) {\n        obj[path] = null;\n        continue;\n      } else if (val.constructor.name === 'Object') {\n        any$conditionals = Object.keys(val).some(function (k) {\n          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';\n        });\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(val);\n        } else {\n          var ks = Object.keys(val),\n              $cond;\n          k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n\n            if ($cond === '$exists') {\n              if (typeof nested !== 'boolean') {\n                throw new Error('$exists parameter must be Boolean');\n              }\n\n              continue;\n            }\n\n            if ($cond === '$not') {\n              if (nested && schematype && !schematype.caster) {\n                _keys = Object.keys(nested);\n\n                if (_keys.length && _keys[0].charAt(0) === '$') {\n                  for (var key in nested) {\n                    nested[key] = schematype.castForQuery(key, nested[key]);\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery($cond, nested);\n                }\n\n                continue;\n              }\n\n              cast(schematype.caster ? schematype.caster.schema : schema, nested);\n            } else {\n              val[$cond] = schematype.castForQuery($cond, nested);\n            }\n          }\n        }\n      } else {\n        obj[path] = schematype.castForQuery(val);\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype) {\n  if (Array.isArray(val)) {\n    val.forEach(function (item, i) {\n      if (Array.isArray(item) || utils.isObject(item)) {\n        return _cast(item, numbertype);\n      }\n\n      val[i] = numbertype.castForQuery(item);\n    });\n  } else {\n    var nearKeys = Object.keys(val);\n    var nearLen = nearKeys.length;\n\n    while (nearLen--) {\n      var nkey = nearKeys[nearLen];\n      var item = val[nkey];\n\n      if (Array.isArray(item) || utils.isObject(item)) {\n        _cast(item, numbertype);\n\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery(item);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/SATAN/darelist/client/node_modules/mongoose/lib/cast.js"],"names":["StrictModeError","require","Types","utils","ALLOWED_GEOWITHIN_GEOJSON_TYPES","module","exports","cast","schema","obj","options","paths","Object","keys","i","length","_keys","any$conditionals","schematype","nested","path","type","val","k","Error","toString","split","j","pathFirstHalf","pathLastHalf","remainingConds","slice","join","caster","isObject","geo","$near","$nearSphere","$within","$geoIntersects","$geoWithin","numbertype","Number","value","$maxDistance","castForQuery","$minDistance","withinType","$center","$centerSphere","$box","$polygon","JSON","stringify","Array","isArray","coordinates","$geometry","isMongooseObject","toObject","transform","virtuals","geoWithinType","indexOf","_cast","upsert","strict","undefined","constructor","name","some","charAt","ks","$cond","key","forEach","item","nearKeys","nearLen","nkey"],"mappings":"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","sourcesContent":["/*!\n * Module dependencies.\n */\n\nvar StrictModeError = require('./error/strict');\nvar Types = require('./schema/index');\nvar utils = require('./utils');\n\nvar ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for queries\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} options the query options\n * @api private\n */\nmodule.exports = function cast(schema, obj, options) {\n  var paths = Object.keys(obj),\n      i = paths.length,\n      _keys,\n      any$conditionals,\n      schematype,\n      nested,\n      path,\n      type,\n      val;\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      var k = val.length;\n\n      while (k--) {\n        val[k] = cast(schema, val[k]);\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        var split = path.split('.'),\n            j = split.length,\n            pathFirstHalf,\n            pathLastHalf,\n            remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (utils.isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          var geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            var numbertype = new Types.Number('__QueryCasting__');\n            var value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(val.$maxDistance);\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(val.$minDistance);\n            }\n\n            if (geo === '$within') {\n              var withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within paramater: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(value.$maxDistance);\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(value.$minDistance);\n              }\n              if (utils.isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (utils.isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                var geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (utils.isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype);\n          }\n        }\n\n        if (options && options.upsert && options.strict) {\n          if (options.strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        }\n      } else if (val === null || val === undefined) {\n        obj[path] = null;\n        continue;\n      } else if (val.constructor.name === 'Object') {\n        any$conditionals = Object.keys(val).some(function(k) {\n          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';\n        });\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(val);\n        } else {\n          var ks = Object.keys(val),\n              $cond;\n\n          k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n\n            if ($cond === '$exists') {\n              if (typeof nested !== 'boolean') {\n                throw new Error('$exists parameter must be Boolean');\n              }\n              continue;\n            }\n\n            if ($cond === '$not') {\n              if (nested && schematype && !schematype.caster) {\n                _keys = Object.keys(nested);\n                if (_keys.length && _keys[0].charAt(0) === '$') {\n                  for (var key in nested) {\n                    nested[key] = schematype.castForQuery(key, nested[key]);\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery($cond, nested);\n                }\n                continue;\n              }\n              cast(schematype.caster ? schematype.caster.schema : schema, nested);\n            } else {\n              val[$cond] = schematype.castForQuery($cond, nested);\n            }\n          }\n        }\n      } else {\n        obj[path] = schematype.castForQuery(val);\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || utils.isObject(item)) {\n        return _cast(item, numbertype);\n      }\n      val[i] = numbertype.castForQuery(item);\n    });\n  } else {\n    var nearKeys = Object.keys(val);\n    var nearLen = nearKeys.length;\n    while (nearLen--) {\n      var nkey = nearKeys[nearLen];\n      var item = val[nkey];\n      if (Array.isArray(item) || utils.isObject(item)) {\n        _cast(item, numbertype);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery(item);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}