{"ast":null,"code":"/*!\n * Module dependencies.\n */\nvar EmbeddedDocument = require('./embedded');\n\nvar Document = require('../document');\n\nvar ObjectId = require('./objectid');\n\nvar utils = require('../utils');\n\nvar isMongooseObject = utils.isMongooseObject;\n/**\n * Mongoose Array constructor.\n *\n * ####NOTE:\n *\n * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._\n *\n * @param {Array} values\n * @param {String} path\n * @param {Document} doc parent document\n * @api private\n * @inherits Array\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseArray(values, path, doc) {\n  var arr = [].concat(values);\n  var keysMA = Object.keys(MongooseArray.mixin);\n  var numKeys = keysMA.length;\n\n  for (var i = 0; i < numKeys; ++i) {\n    arr[keysMA[i]] = MongooseArray.mixin[keysMA[i]];\n  }\n\n  arr._path = path;\n  arr.isMongooseArray = true;\n  arr.validators = [];\n  arr._atomics = {};\n  arr._schema = void 0; // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n\n  if (doc && doc instanceof Document) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n  }\n\n  return arr;\n}\n\nMongooseArray.mixin = {\n  /*!\n   * ignore\n   */\n  toBSON: function () {\n    return this.toObject({\n      transform: false,\n      virtuals: false\n    });\n  },\n\n  /**\n   * Stores a queue of atomic operations to perform\n   *\n   * @property _atomics\n   * @api private\n   */\n  _atomics: undefined,\n\n  /**\n   * Parent owner document\n   *\n   * @property _parent\n   * @api private\n   * @receiver MongooseArray\n   */\n  _parent: undefined,\n\n  /**\n   * Casts a member based on this arrays schema.\n   *\n   * @param {any} value\n   * @return value the casted value\n   * @method _cast\n   * @api private\n   * @receiver MongooseArray\n   */\n  _cast: function (value) {\n    var populated = false;\n    var Model;\n\n    if (this._parent) {\n      populated = this._parent.populated(this._path, true);\n    }\n\n    if (populated && value !== null && value !== undefined) {\n      // cast to the populated Models schema\n      Model = populated.options.model; // only objects are permitted so we can safely assume that\n      // non-objects are to be interpreted as _id\n\n      if (Buffer.isBuffer(value) || value instanceof ObjectId || !utils.isObject(value)) {\n        value = {\n          _id: value\n        };\n      } // gh-2399\n      // we should cast model only when it's not a discriminator\n\n\n      var isDisc = value.schema && value.schema.discriminatorMapping && value.schema.discriminatorMapping.key !== undefined;\n\n      if (!isDisc) {\n        value = new Model(value);\n      }\n\n      return this._schema.caster.cast(value, this._parent, true);\n    }\n\n    return this._schema.caster.cast(value, this._parent, false);\n  },\n\n  /**\n   * Marks this array as modified.\n   *\n   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n   *\n   * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array\n   * @param {String} embeddedPath the path which changed in the embeddedDoc\n   * @method _markModified\n   * @api private\n   * @receiver MongooseArray\n   */\n  _markModified: function (elem, embeddedPath) {\n    var parent = this._parent,\n        dirtyPath;\n\n    if (parent) {\n      dirtyPath = this._path;\n\n      if (arguments.length) {\n        if (embeddedPath != null) {\n          // an embedded doc bubbled up the change\n          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;\n        } else {\n          // directly set an index\n          dirtyPath = dirtyPath + '.' + elem;\n        }\n      }\n\n      parent.markModified(dirtyPath);\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an atomic operation with the parent.\n   *\n   * @param {Array} op operation\n   * @param {any} val\n   * @method _registerAtomic\n   * @api private\n   * @receiver MongooseArray\n   */\n  _registerAtomic: function (op, val) {\n    if (op === '$set') {\n      // $set takes precedence over all other ops.\n      // mark entire array modified.\n      this._atomics = {\n        $set: val\n      };\n      return this;\n    }\n\n    var atomics = this._atomics; // reset pop/shift after save\n\n    if (op === '$pop' && !('$pop' in atomics)) {\n      var _this = this;\n\n      this._parent.once('save', function () {\n        _this._popped = _this._shifted = null;\n      });\n    } // check for impossible $atomic combos (Mongo denies more than one\n    // $atomic op on a single path\n\n\n    if (this._atomics.$set || Object.keys(atomics).length && !(op in atomics)) {\n      // a different op was previously registered.\n      // save the entire thing.\n      this._atomics = {\n        $set: this\n      };\n      return this;\n    }\n\n    var selector;\n\n    if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') {\n      atomics[op] || (atomics[op] = []);\n      atomics[op] = atomics[op].concat(val);\n    } else if (op === '$pullDocs') {\n      var pullOp = atomics['$pull'] || (atomics['$pull'] = {});\n\n      if (val[0] instanceof EmbeddedDocument) {\n        selector = pullOp['$or'] || (pullOp['$or'] = []);\n        Array.prototype.push.apply(selector, val.map(function (v) {\n          return v.toObject({\n            transform: false,\n            virtuals: false\n          });\n        }));\n      } else {\n        selector = pullOp['_id'] || (pullOp['_id'] = {\n          $in: []\n        });\n        selector['$in'] = selector['$in'].concat(val);\n      }\n    } else {\n      atomics[op] = val;\n    }\n\n    return this;\n  },\n\n  /**\n   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.\n   *\n   * If no atomics exist, we return all array values after conversion.\n   *\n   * @return {Array}\n   * @method $__getAtomics\n   * @memberOf MongooseArray\n   * @api private\n   */\n  $__getAtomics: function () {\n    var ret = [];\n    var keys = Object.keys(this._atomics);\n    var i = keys.length;\n\n    if (i === 0) {\n      ret[0] = ['$set', this.toObject({\n        depopulate: 1,\n        transform: false,\n        _isNested: true,\n        virtuals: false\n      })];\n      return ret;\n    }\n\n    while (i--) {\n      var op = keys[i];\n      var val = this._atomics[op]; // the atomic values which are arrays are not MongooseArrays. we\n      // need to convert their elements as if they were MongooseArrays\n      // to handle populated arrays versus DocumentArrays properly.\n\n      if (isMongooseObject(val)) {\n        val = val.toObject({\n          depopulate: 1,\n          transform: false,\n          _isNested: true,\n          virtuals: false\n        });\n      } else if (Array.isArray(val)) {\n        val = this.toObject.call(val, {\n          depopulate: 1,\n          transform: false,\n          _isNested: true\n        });\n      } else if (val.valueOf) {\n        val = val.valueOf();\n      }\n\n      if (op === '$addToSet') {\n        val = {\n          $each: val\n        };\n      }\n\n      ret.push([op, val]);\n    }\n\n    return ret;\n  },\n\n  /**\n   * Returns the number of pending atomic operations to send to the db for this array.\n   *\n   * @api private\n   * @return {Number}\n   * @method hasAtomics\n   * @receiver MongooseArray\n   */\n  hasAtomics: function hasAtomics() {\n    if (!(this._atomics && this._atomics.constructor.name === 'Object')) {\n      return 0;\n    }\n\n    return Object.keys(this._atomics).length;\n  },\n\n  /**\n   * Internal helper for .map()\n   *\n   * @api private\n   * @return {Number}\n   * @method _mapCast\n   * @receiver MongooseArray\n   */\n  _mapCast: function (val, index) {\n    return this._cast(val, this.length + index);\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * @param {Object} [args...]\n   * @api public\n   * @method push\n   * @receiver MongooseArray\n   */\n  push: function () {\n    var values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent, undefined, undefined, {\n      skipDocumentArrayCast: true\n    });\n    var ret = [].push.apply(this, values); // $pushAll might be fibbed (could be $push). But it makes it easier to\n    // handle what could have been $push, $pushAll combos\n\n    this._registerAtomic('$pushAll', values);\n\n    this._markModified();\n\n    return ret;\n  },\n\n  /**\n   * Pushes items to the array non-atomically.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @param {any} [args...]\n   * @api public\n   * @method nonAtomicPush\n   * @receiver MongooseArray\n   */\n  nonAtomicPush: function () {\n    var values = [].map.call(arguments, this._mapCast, this);\n    var ret = [].push.apply(this, values);\n\n    this._registerAtomic('$set', this);\n\n    this._markModified();\n\n    return ret;\n  },\n\n  /**\n   * Pops the array atomically at most one time per document `save()`.\n   *\n   * #### NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var popped = doc.array.$pop();\n   *      console.log(popped); // 3\n   *      console.log(doc.array); // [1,2]\n   *\n   *      // no affect\n   *      popped = doc.array.$pop();\n   *      console.log(doc.array); // [1,2]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $pop works again\n   *        popped = doc.array.$pop();\n   *        console.log(popped); // 2\n   *        console.log(doc.array); // [1]\n   *      })\n   *\n   * @api public\n   * @method $pop\n   * @memberOf MongooseArray\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   * @method $pop\n   * @receiver MongooseArray\n   */\n  $pop: function () {\n    this._registerAtomic('$pop', 1);\n\n    this._markModified(); // only allow popping once\n\n\n    if (this._popped) {\n      return;\n    }\n\n    this._popped = true;\n    return [].pop.call(this);\n  },\n\n  /**\n   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @see MongooseArray#$pop #types_array_MongooseArray-%24pop\n   * @api public\n   * @method pop\n   * @receiver MongooseArray\n   */\n  pop: function () {\n    var ret = [].pop.call(this);\n\n    this._registerAtomic('$set', this);\n\n    this._markModified();\n\n    return ret;\n  },\n\n  /**\n   * Atomically shifts the array at most one time per document `save()`.\n   *\n   * ####NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var shifted = doc.array.$shift();\n   *      console.log(shifted); // 1\n   *      console.log(doc.array); // [2,3]\n   *\n   *      // no affect\n   *      shifted = doc.array.$shift();\n   *      console.log(doc.array); // [2,3]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $shift works again\n   *        shifted = doc.array.$shift();\n   *        console.log(shifted ); // 2\n   *        console.log(doc.array); // [3]\n   *      })\n   *\n   * @api public\n   * @memberOf MongooseArray\n   * @method $shift\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   */\n  $shift: function $shift() {\n    this._registerAtomic('$pop', -1);\n\n    this._markModified(); // only allow shifting once\n\n\n    if (this._shifted) {\n      return;\n    }\n\n    this._shifted = true;\n    return [].shift.call(this);\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Example:\n   *\n   *     doc.array = [2,3];\n   *     var res = doc.array.shift();\n   *     console.log(res) // 2\n   *     console.log(doc.array) // [3]\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method shift\n   * @receiver MongooseArray\n   */\n  shift: function () {\n    var ret = [].shift.call(this);\n\n    this._registerAtomic('$set', this);\n\n    this._markModified();\n\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically. Equality is determined by casting\n   * the provided value to an embedded document and comparing using\n   * [the `Document.equals()` function.](./api.html#document_Document-equals)\n   *\n   * ####Examples:\n   *\n   *     doc.array.pull(ObjectId)\n   *     doc.array.pull({ _id: 'someId' })\n   *     doc.array.pull(36)\n   *     doc.array.pull('tag 1', 'tag 2')\n   *\n   * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n   *\n   * Or we may passing the _id directly and let mongoose take care of it.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull(4815162342); // works\n   *\n   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n   *\n   * @param {any} [args...]\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n   * @api public\n   * @method pull\n   * @receiver MongooseArray\n   */\n  pull: function () {\n    var values = [].map.call(arguments, this._cast, this),\n        cur = this._parent.get(this._path),\n        i = cur.length,\n        mem;\n\n    while (i--) {\n      mem = cur[i];\n\n      if (mem instanceof Document) {\n        var some = values.some(function (v) {\n          return mem.equals(v);\n        });\n\n        if (some) {\n          [].splice.call(cur, i, 1);\n        }\n      } else if (~cur.indexOf.call(values, mem)) {\n        [].splice.call(cur, i, 1);\n      }\n    }\n\n    if (values[0] instanceof EmbeddedDocument) {\n      this._registerAtomic('$pullDocs', values.map(function (v) {\n        return v._id || v;\n      }));\n    } else {\n      this._registerAtomic('$pullAll', values);\n    }\n\n    this._markModified();\n\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method splice\n   * @receiver MongooseArray\n   */\n  splice: function splice() {\n    var ret, vals, i;\n\n    if (arguments.length) {\n      vals = [];\n\n      for (i = 0; i < arguments.length; ++i) {\n        vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2));\n      }\n\n      ret = [].splice.apply(this, vals);\n\n      this._registerAtomic('$set', this);\n\n      this._markModified();\n    }\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method unshift\n   * @receiver MongooseArray\n   */\n  unshift: function () {\n    var values = [].map.call(arguments, this._cast, this);\n    values = this._schema.applySetters(values, this._parent);\n    [].unshift.apply(this, values);\n\n    this._registerAtomic('$set', this);\n\n    this._markModified();\n\n    return this.length;\n  },\n\n  /**\n   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method sort\n   * @receiver MongooseArray\n   */\n  sort: function () {\n    var ret = [].sort.apply(this, arguments);\n\n    this._registerAtomic('$set', this);\n\n    this._markModified();\n\n    return ret;\n  },\n\n  /**\n   * Adds values to the array if not already present.\n   *\n   * ####Example:\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *     var added = doc.array.addToSet(4,5);\n   *     console.log(doc.array) // [2,3,4,5]\n   *     console.log(added)     // [5]\n   *\n   * @param {any} [args...]\n   * @return {Array} the values that were added\n   * @receiver MongooseArray\n   * @api public\n   * @method addToSet\n   */\n  addToSet: function addToSet() {\n    var values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent);\n    var added = [];\n    var type = '';\n\n    if (values[0] instanceof EmbeddedDocument) {\n      type = 'doc';\n    } else if (values[0] instanceof Date) {\n      type = 'date';\n    }\n\n    values.forEach(function (v) {\n      var found;\n\n      switch (type) {\n        case 'doc':\n          found = this.some(function (doc) {\n            return doc.equals(v);\n          });\n          break;\n\n        case 'date':\n          var val = +v;\n          found = this.some(function (d) {\n            return +d === val;\n          });\n          break;\n\n        default:\n          found = ~this.indexOf(v);\n      }\n\n      if (!found) {\n        [].push.call(this, v);\n\n        this._registerAtomic('$addToSet', v);\n\n        this._markModified();\n\n        [].push.call(added, v);\n      }\n    }, this);\n    return added;\n  },\n\n  /**\n   * Sets the casted `val` at index `i` and marks the array modified.\n   *\n   * ####Example:\n   *\n   *     // given documents based on the following\n   *     var Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n   *\n   *     var doc = new Doc({ array: [2,3,4] })\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *\n   *     doc.array.set(1,\"5\");\n   *     console.log(doc.array); // [2,5,4] // properly cast to number\n   *     doc.save() // the change is saved\n   *\n   *     // VS not using array#set\n   *     doc.array[1] = \"5\";\n   *     console.log(doc.array); // [2,\"5\",4] // no casting\n   *     doc.save() // change is not saved\n   *\n   * @return {Array} this\n   * @api public\n   * @method set\n   * @receiver MongooseArray\n   */\n  set: function set(i, val) {\n    var value = this._cast(val, i);\n\n    value = this._schema.caster instanceof EmbeddedDocument ? value : this._schema.caster.applySetters(val, this._parent);\n    this[i] = value;\n\n    this._markModified(i);\n\n    return this;\n  },\n\n  /**\n   * Returns a native js Array.\n   *\n   * @param {Object} options\n   * @return {Array}\n   * @api public\n   * @method toObject\n   * @receiver MongooseArray\n   */\n  toObject: function (options) {\n    if (options && options.depopulate) {\n      options._isNested = true;\n      return this.map(function (doc) {\n        return doc instanceof Document ? doc.toObject(options) : doc;\n      });\n    }\n\n    return this.slice();\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @api public\n   * @method inspect\n   * @receiver MongooseArray\n   */\n  inspect: function () {\n    return JSON.stringify(this);\n  },\n\n  /**\n   * Return the index of `obj` or `-1` if not found.\n   *\n   * @param {Object} obj the item to look for\n   * @return {Number}\n   * @api public\n   * @method indexOf\n   * @receiver MongooseArray\n   */\n  indexOf: function indexOf(obj) {\n    if (obj instanceof ObjectId) {\n      obj = obj.toString();\n    }\n\n    for (var i = 0, len = this.length; i < len; ++i) {\n      if (obj == this[i]) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n};\n/**\n * Alias of [pull](#types_array_MongooseArray-pull)\n *\n * @see MongooseArray#pull #types_array_MongooseArray-pull\n * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n * @api public\n * @memberOf MongooseArray\n * @method remove\n */\n\nMongooseArray.mixin.remove = MongooseArray.mixin.pull;\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseArray;","map":{"version":3,"sources":["C:/Users/SATAN/darelist/client/node_modules/mongoose/lib/types/array.js"],"names":["EmbeddedDocument","require","Document","ObjectId","utils","isMongooseObject","MongooseArray","values","path","doc","arr","concat","keysMA","Object","keys","mixin","numKeys","length","i","_path","isMongooseArray","validators","_atomics","_schema","_parent","schema","toBSON","toObject","transform","virtuals","undefined","_cast","value","populated","Model","options","model","Buffer","isBuffer","isObject","_id","isDisc","discriminatorMapping","key","caster","cast","_markModified","elem","embeddedPath","parent","dirtyPath","arguments","indexOf","markModified","_registerAtomic","op","val","$set","atomics","_this","once","_popped","_shifted","selector","pullOp","Array","prototype","push","apply","map","v","$in","$__getAtomics","ret","depopulate","_isNested","isArray","call","valueOf","$each","hasAtomics","constructor","name","_mapCast","index","applySetters","skipDocumentArrayCast","nonAtomicPush","$pop","pop","$shift","shift","pull","cur","get","mem","some","equals","splice","vals","unshift","sort","addToSet","added","type","Date","forEach","found","d","set","slice","inspect","JSON","stringify","obj","toString","len","remove","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Module dependencies.\n */\n\nvar EmbeddedDocument = require('./embedded');\nvar Document = require('../document');\nvar ObjectId = require('./objectid');\nvar utils = require('../utils');\nvar isMongooseObject = utils.isMongooseObject;\n\n/**\n * Mongoose Array constructor.\n *\n * ####NOTE:\n *\n * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._\n *\n * @param {Array} values\n * @param {String} path\n * @param {Document} doc parent document\n * @api private\n * @inherits Array\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseArray(values, path, doc) {\n  var arr = [].concat(values);\n\n  var keysMA = Object.keys(MongooseArray.mixin);\n  var numKeys = keysMA.length;\n  for (var i = 0; i < numKeys; ++i) {\n    arr[keysMA[i]] = MongooseArray.mixin[keysMA[i]];\n  }\n\n  arr._path = path;\n  arr.isMongooseArray = true;\n  arr.validators = [];\n  arr._atomics = {};\n  arr._schema = void 0;\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc && doc instanceof Document) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n  }\n\n  return arr;\n}\n\nMongooseArray.mixin = {\n  /*!\n   * ignore\n   */\n  toBSON: function() {\n    return this.toObject({ transform: false, virtuals: false });\n  },\n\n  /**\n   * Stores a queue of atomic operations to perform\n   *\n   * @property _atomics\n   * @api private\n   */\n\n  _atomics: undefined,\n\n  /**\n   * Parent owner document\n   *\n   * @property _parent\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _parent: undefined,\n\n  /**\n   * Casts a member based on this arrays schema.\n   *\n   * @param {any} value\n   * @return value the casted value\n   * @method _cast\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _cast: function(value) {\n    var populated = false;\n    var Model;\n\n    if (this._parent) {\n      populated = this._parent.populated(this._path, true);\n    }\n\n    if (populated && value !== null && value !== undefined) {\n      // cast to the populated Models schema\n      Model = populated.options.model;\n\n      // only objects are permitted so we can safely assume that\n      // non-objects are to be interpreted as _id\n      if (Buffer.isBuffer(value) ||\n          value instanceof ObjectId || !utils.isObject(value)) {\n        value = {_id: value};\n      }\n\n      // gh-2399\n      // we should cast model only when it's not a discriminator\n      var isDisc = value.schema && value.schema.discriminatorMapping &&\n          value.schema.discriminatorMapping.key !== undefined;\n      if (!isDisc) {\n        value = new Model(value);\n      }\n      return this._schema.caster.cast(value, this._parent, true);\n    }\n\n    return this._schema.caster.cast(value, this._parent, false);\n  },\n\n  /**\n   * Marks this array as modified.\n   *\n   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n   *\n   * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array\n   * @param {String} embeddedPath the path which changed in the embeddedDoc\n   * @method _markModified\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _markModified: function(elem, embeddedPath) {\n    var parent = this._parent,\n        dirtyPath;\n\n    if (parent) {\n      dirtyPath = this._path;\n\n      if (arguments.length) {\n        if (embeddedPath != null) {\n          // an embedded doc bubbled up the change\n          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;\n        } else {\n          // directly set an index\n          dirtyPath = dirtyPath + '.' + elem;\n        }\n      }\n\n      parent.markModified(dirtyPath);\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an atomic operation with the parent.\n   *\n   * @param {Array} op operation\n   * @param {any} val\n   * @method _registerAtomic\n   * @api private\n   * @receiver MongooseArray\n   */\n\n  _registerAtomic: function(op, val) {\n    if (op === '$set') {\n      // $set takes precedence over all other ops.\n      // mark entire array modified.\n      this._atomics = {$set: val};\n      return this;\n    }\n\n    var atomics = this._atomics;\n\n    // reset pop/shift after save\n    if (op === '$pop' && !('$pop' in atomics)) {\n      var _this = this;\n      this._parent.once('save', function() {\n        _this._popped = _this._shifted = null;\n      });\n    }\n\n    // check for impossible $atomic combos (Mongo denies more than one\n    // $atomic op on a single path\n    if (this._atomics.$set ||\n        Object.keys(atomics).length && !(op in atomics)) {\n      // a different op was previously registered.\n      // save the entire thing.\n      this._atomics = {$set: this};\n      return this;\n    }\n\n    var selector;\n\n    if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') {\n      atomics[op] || (atomics[op] = []);\n      atomics[op] = atomics[op].concat(val);\n    } else if (op === '$pullDocs') {\n      var pullOp = atomics['$pull'] || (atomics['$pull'] = {});\n      if (val[0] instanceof EmbeddedDocument) {\n        selector = pullOp['$or'] || (pullOp['$or'] = []);\n        Array.prototype.push.apply(selector, val.map(function(v) {\n          return v.toObject({transform: false, virtuals: false});\n        }));\n      } else {\n        selector = pullOp['_id'] || (pullOp['_id'] = {$in: []});\n        selector['$in'] = selector['$in'].concat(val);\n      }\n    } else {\n      atomics[op] = val;\n    }\n\n    return this;\n  },\n\n  /**\n   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.\n   *\n   * If no atomics exist, we return all array values after conversion.\n   *\n   * @return {Array}\n   * @method $__getAtomics\n   * @memberOf MongooseArray\n   * @api private\n   */\n\n  $__getAtomics: function() {\n    var ret = [];\n    var keys = Object.keys(this._atomics);\n    var i = keys.length;\n\n    if (i === 0) {\n      ret[0] = ['$set', this.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false})];\n      return ret;\n    }\n\n    while (i--) {\n      var op = keys[i];\n      var val = this._atomics[op];\n\n      // the atomic values which are arrays are not MongooseArrays. we\n      // need to convert their elements as if they were MongooseArrays\n      // to handle populated arrays versus DocumentArrays properly.\n      if (isMongooseObject(val)) {\n        val = val.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false});\n      } else if (Array.isArray(val)) {\n        val = this.toObject.call(val, {depopulate: 1, transform: false, _isNested: true});\n      } else if (val.valueOf) {\n        val = val.valueOf();\n      }\n\n      if (op === '$addToSet') {\n        val = {$each: val};\n      }\n\n      ret.push([op, val]);\n    }\n\n    return ret;\n  },\n\n  /**\n   * Returns the number of pending atomic operations to send to the db for this array.\n   *\n   * @api private\n   * @return {Number}\n   * @method hasAtomics\n   * @receiver MongooseArray\n   */\n\n  hasAtomics: function hasAtomics() {\n    if (!(this._atomics && this._atomics.constructor.name === 'Object')) {\n      return 0;\n    }\n\n    return Object.keys(this._atomics).length;\n  },\n\n  /**\n   * Internal helper for .map()\n   *\n   * @api private\n   * @return {Number}\n   * @method _mapCast\n   * @receiver MongooseArray\n   */\n  _mapCast: function(val, index) {\n    return this._cast(val, this.length + index);\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * @param {Object} [args...]\n   * @api public\n   * @method push\n   * @receiver MongooseArray\n   */\n\n  push: function() {\n    var values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent, undefined,\n        undefined, {skipDocumentArrayCast: true});\n    var ret = [].push.apply(this, values);\n\n    // $pushAll might be fibbed (could be $push). But it makes it easier to\n    // handle what could have been $push, $pushAll combos\n    this._registerAtomic('$pushAll', values);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pushes items to the array non-atomically.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @param {any} [args...]\n   * @api public\n   * @method nonAtomicPush\n   * @receiver MongooseArray\n   */\n\n  nonAtomicPush: function() {\n    var values = [].map.call(arguments, this._mapCast, this);\n    var ret = [].push.apply(this, values);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pops the array atomically at most one time per document `save()`.\n   *\n   * #### NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var popped = doc.array.$pop();\n   *      console.log(popped); // 3\n   *      console.log(doc.array); // [1,2]\n   *\n   *      // no affect\n   *      popped = doc.array.$pop();\n   *      console.log(doc.array); // [1,2]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $pop works again\n   *        popped = doc.array.$pop();\n   *        console.log(popped); // 2\n   *        console.log(doc.array); // [1]\n   *      })\n   *\n   * @api public\n   * @method $pop\n   * @memberOf MongooseArray\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   * @method $pop\n   * @receiver MongooseArray\n   */\n\n  $pop: function() {\n    this._registerAtomic('$pop', 1);\n    this._markModified();\n\n    // only allow popping once\n    if (this._popped) {\n      return;\n    }\n    this._popped = true;\n\n    return [].pop.call(this);\n  },\n\n  /**\n   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @see MongooseArray#$pop #types_array_MongooseArray-%24pop\n   * @api public\n   * @method pop\n   * @receiver MongooseArray\n   */\n\n  pop: function() {\n    var ret = [].pop.call(this);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Atomically shifts the array at most one time per document `save()`.\n   *\n   * ####NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var shifted = doc.array.$shift();\n   *      console.log(shifted); // 1\n   *      console.log(doc.array); // [2,3]\n   *\n   *      // no affect\n   *      shifted = doc.array.$shift();\n   *      console.log(doc.array); // [2,3]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $shift works again\n   *        shifted = doc.array.$shift();\n   *        console.log(shifted ); // 2\n   *        console.log(doc.array); // [3]\n   *      })\n   *\n   * @api public\n   * @memberOf MongooseArray\n   * @method $shift\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   */\n\n  $shift: function $shift() {\n    this._registerAtomic('$pop', -1);\n    this._markModified();\n\n    // only allow shifting once\n    if (this._shifted) {\n      return;\n    }\n    this._shifted = true;\n\n    return [].shift.call(this);\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Example:\n   *\n   *     doc.array = [2,3];\n   *     var res = doc.array.shift();\n   *     console.log(res) // 2\n   *     console.log(doc.array) // [3]\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method shift\n   * @receiver MongooseArray\n   */\n\n  shift: function() {\n    var ret = [].shift.call(this);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically. Equality is determined by casting\n   * the provided value to an embedded document and comparing using\n   * [the `Document.equals()` function.](./api.html#document_Document-equals)\n   *\n   * ####Examples:\n   *\n   *     doc.array.pull(ObjectId)\n   *     doc.array.pull({ _id: 'someId' })\n   *     doc.array.pull(36)\n   *     doc.array.pull('tag 1', 'tag 2')\n   *\n   * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n   *\n   * Or we may passing the _id directly and let mongoose take care of it.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull(4815162342); // works\n   *\n   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n   *\n   * @param {any} [args...]\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n   * @api public\n   * @method pull\n   * @receiver MongooseArray\n   */\n\n  pull: function() {\n    var values = [].map.call(arguments, this._cast, this),\n        cur = this._parent.get(this._path),\n        i = cur.length,\n        mem;\n\n    while (i--) {\n      mem = cur[i];\n      if (mem instanceof Document) {\n        var some = values.some(function(v) {\n          return mem.equals(v);\n        });\n        if (some) {\n          [].splice.call(cur, i, 1);\n        }\n      } else if (~cur.indexOf.call(values, mem)) {\n        [].splice.call(cur, i, 1);\n      }\n    }\n\n    if (values[0] instanceof EmbeddedDocument) {\n      this._registerAtomic('$pullDocs', values.map(function(v) {\n        return v._id || v;\n      }));\n    } else {\n      this._registerAtomic('$pullAll', values);\n    }\n\n    this._markModified();\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method splice\n   * @receiver MongooseArray\n   */\n\n  splice: function splice() {\n    var ret, vals, i;\n\n    if (arguments.length) {\n      vals = [];\n      for (i = 0; i < arguments.length; ++i) {\n        vals[i] = i < 2\n            ? arguments[i]\n            : this._cast(arguments[i], arguments[0] + (i - 2));\n      }\n      ret = [].splice.apply(this, vals);\n      this._registerAtomic('$set', this);\n      this._markModified();\n    }\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method unshift\n   * @receiver MongooseArray\n   */\n\n  unshift: function() {\n    var values = [].map.call(arguments, this._cast, this);\n    values = this._schema.applySetters(values, this._parent);\n    [].unshift.apply(this, values);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return this.length;\n  },\n\n  /**\n   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method sort\n   * @receiver MongooseArray\n   */\n\n  sort: function() {\n    var ret = [].sort.apply(this, arguments);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Adds values to the array if not already present.\n   *\n   * ####Example:\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *     var added = doc.array.addToSet(4,5);\n   *     console.log(doc.array) // [2,3,4,5]\n   *     console.log(added)     // [5]\n   *\n   * @param {any} [args...]\n   * @return {Array} the values that were added\n   * @receiver MongooseArray\n   * @api public\n   * @method addToSet\n   */\n\n  addToSet: function addToSet() {\n    var values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent);\n    var added = [];\n    var type = '';\n    if (values[0] instanceof EmbeddedDocument) {\n      type = 'doc';\n    } else if (values[0] instanceof Date) {\n      type = 'date';\n    }\n\n    values.forEach(function(v) {\n      var found;\n      switch (type) {\n        case 'doc':\n          found = this.some(function(doc) {\n            return doc.equals(v);\n          });\n          break;\n        case 'date':\n          var val = +v;\n          found = this.some(function(d) {\n            return +d === val;\n          });\n          break;\n        default:\n          found = ~this.indexOf(v);\n      }\n\n      if (!found) {\n        [].push.call(this, v);\n        this._registerAtomic('$addToSet', v);\n        this._markModified();\n        [].push.call(added, v);\n      }\n    }, this);\n\n    return added;\n  },\n\n  /**\n   * Sets the casted `val` at index `i` and marks the array modified.\n   *\n   * ####Example:\n   *\n   *     // given documents based on the following\n   *     var Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n   *\n   *     var doc = new Doc({ array: [2,3,4] })\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *\n   *     doc.array.set(1,\"5\");\n   *     console.log(doc.array); // [2,5,4] // properly cast to number\n   *     doc.save() // the change is saved\n   *\n   *     // VS not using array#set\n   *     doc.array[1] = \"5\";\n   *     console.log(doc.array); // [2,\"5\",4] // no casting\n   *     doc.save() // change is not saved\n   *\n   * @return {Array} this\n   * @api public\n   * @method set\n   * @receiver MongooseArray\n   */\n\n  set: function set(i, val) {\n    var value = this._cast(val, i);\n    value = this._schema.caster instanceof EmbeddedDocument ?\n        value :\n        this._schema.caster.applySetters(val, this._parent)\n    ;\n    this[i] = value;\n    this._markModified(i);\n    return this;\n  },\n\n  /**\n   * Returns a native js Array.\n   *\n   * @param {Object} options\n   * @return {Array}\n   * @api public\n   * @method toObject\n   * @receiver MongooseArray\n   */\n\n  toObject: function(options) {\n    if (options && options.depopulate) {\n      options._isNested = true;\n      return this.map(function(doc) {\n        return doc instanceof Document\n            ? doc.toObject(options)\n            : doc;\n      });\n    }\n\n    return this.slice();\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @api public\n   * @method inspect\n   * @receiver MongooseArray\n   */\n\n  inspect: function() {\n    return JSON.stringify(this);\n  },\n\n  /**\n   * Return the index of `obj` or `-1` if not found.\n   *\n   * @param {Object} obj the item to look for\n   * @return {Number}\n   * @api public\n   * @method indexOf\n   * @receiver MongooseArray\n   */\n\n  indexOf: function indexOf(obj) {\n    if (obj instanceof ObjectId) {\n      obj = obj.toString();\n    }\n    for (var i = 0, len = this.length; i < len; ++i) {\n      if (obj == this[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n};\n\n/**\n * Alias of [pull](#types_array_MongooseArray-pull)\n *\n * @see MongooseArray#pull #types_array_MongooseArray-pull\n * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n * @api public\n * @memberOf MongooseArray\n * @method remove\n */\n\nMongooseArray.mixin.remove = MongooseArray.mixin.pull;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseArray;\n"]},"metadata":{},"sourceType":"script"}