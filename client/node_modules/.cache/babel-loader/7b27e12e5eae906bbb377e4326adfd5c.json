{"ast":null,"code":"/*!\n * Module dependencies.\n */\nvar SchemaType = require('../schematype');\n\nvar CastError = SchemaType.CastError;\nvar Types = {\n  Boolean: require('./boolean'),\n  Date: require('./date'),\n  Number: require('./number'),\n  String: require('./string'),\n  ObjectId: require('./objectid'),\n  Buffer: require('./buffer')\n};\n\nvar MongooseArray = require('../types').Array;\n\nvar EmbeddedDoc = require('../types').Embedded;\n\nvar Mixed = require('./mixed');\n\nvar cast = require('../cast');\n\nvar util = require('util');\n\nvar utils = require('../utils');\n\nvar castToNumber = require('./operators/helpers').castToNumber;\n\nvar geospatial = require('./operators/geospatial');\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  var typeKey = 'type';\n\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n\n  if (cast) {\n    var castOptions = {};\n\n    if (utils.getFunctionName(cast.constructor) === 'Object') {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    } // support { type: 'String' }\n\n\n    var name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n    var caster = name in Types ? Types[name] : cast;\n    this.casterConstructor = caster;\n\n    if (typeof caster === 'function') {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  SchemaType.call(this, key, options, 'Array');\n  var defaultArr;\n  var fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    this.default(function () {\n      var arr = [];\n\n      if (fn) {\n        arr = defaultArr();\n      } else if (defaultArr != null) {\n        arr = defaultArr;\n      } // Leave it up to `cast()` to convert the array\n\n\n      return arr;\n    });\n  }\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nSchemaArray.schemaName = 'Array';\n/*!\n * Inherits from SchemaType.\n */\n\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\n/**\n * Check if the given value satisfies a required validator. The given value\n * must be not null nor undefined, and have a non-zero length.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function (value) {\n  return !!(value && value.length);\n};\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\n\nSchemaArray.prototype.cast = function (value, doc, init) {\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      var indexes = doc.schema.indexedPaths();\n\n      for (var i = 0, l = indexes.length; i < l; ++i) {\n        var pathIndex = indexes[i][0][this.path];\n\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this.path, doc);\n    }\n\n    if (this.caster) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          value[i] = this.caster.cast(value[i], doc, init);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);\n      }\n    }\n\n    return value;\n  } // gh-2442: if we're loading this from the db and its not an array, mark\n  // the whole array as modified.\n\n\n  if (!!doc && !!init) {\n    doc.markModified(this.path);\n  }\n\n  return this.cast([value], doc, init);\n};\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\n\nSchemaArray.prototype.castForQuery = function ($conditional, value) {\n  var handler, val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    var proto = this.casterConstructor.prototype;\n    var method = proto && (proto.castForQuery || proto.cast);\n    var caster = this.caster;\n\n    if (Array.isArray(val)) {\n      val = val.map(function (v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n\n        if (method) {\n          v = method.call(caster, v);\n        }\n\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function (v) {\n    if (utils.isObject(v)) {\n      var o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n\n    return v;\n  }, this);\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  var keys = Object.keys(val);\n  var numKeys = keys.length;\n  var key;\n  var value;\n\n  for (var i = 0; i < numKeys; ++i) {\n    key = keys[i];\n    value = val[key];\n\n    if (key.indexOf('$') === 0 && value) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nvar handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\n\nhandle.$or = handle.$and = function (val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  var ret = [];\n\n  for (var i = 0; i < val.length; ++i) {\n    ret.push(cast(this.casterConstructor.schema, val[i]));\n  }\n\n  return ret;\n};\n\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$eq = handle.$gt = handle.$gte = handle.$in = handle.$lt = handle.$lte = handle.$ne = handle.$nin = handle.$regex = SchemaArray.prototype.castForQuery;\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"sources":["C:/Users/SATAN/darelist/client/node_modules/mongoose/lib/schema/array.js"],"names":["SchemaType","require","CastError","Types","Boolean","Date","Number","String","ObjectId","Buffer","MongooseArray","Array","EmbeddedDoc","Embedded","Mixed","cast","util","utils","castToNumber","geospatial","SchemaArray","key","options","schemaOptions","typeKey","castOptions","getFunctionName","constructor","clone","name","caster","casterConstructor","path","call","defaultArr","fn","defaultValue","default","arr","schemaName","prototype","Object","create","checkRequired","value","length","applyGetters","scope","ref","doc","init","isArray","indexes","schema","indexedPaths","i","l","pathIndex","isMongooseArray","e","kind","inspect","markModified","castForQuery","$conditional","handler","val","arguments","$conditionalHandlers","Error","proto","method","map","v","isObject","$elemMatch","cast$all","o","cast$elemMatch","keys","numKeys","indexOf","handle","$all","$options","$geoIntersects","cast$geoIntersects","$or","$and","TypeError","ret","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$in","$lt","$lte","$ne","$nin","$regex","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Module dependencies.\n */\n\nvar SchemaType = require('../schematype');\nvar CastError = SchemaType.CastError;\nvar Types = {\n  Boolean: require('./boolean'),\n  Date: require('./date'),\n  Number: require('./number'),\n  String: require('./string'),\n  ObjectId: require('./objectid'),\n  Buffer: require('./buffer')\n};\nvar MongooseArray = require('../types').Array;\nvar EmbeddedDoc = require('../types').Embedded;\nvar Mixed = require('./mixed');\nvar cast = require('../cast');\nvar util = require('util');\nvar utils = require('../utils');\nvar castToNumber = require('./operators/helpers').castToNumber;\nvar geospatial = require('./operators/geospatial');\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  var typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n\n  if (cast) {\n    var castOptions = {};\n\n    if (utils.getFunctionName(cast.constructor) === 'Object') {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    // support { type: 'String' }\n    var name = typeof cast === 'string'\n        ? cast\n        : utils.getFunctionName(cast);\n\n    var caster = name in Types\n        ? Types[name]\n        : cast;\n\n    this.casterConstructor = caster;\n    if (typeof caster === 'function') {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  SchemaType.call(this, key, options, 'Array');\n\n  var defaultArr;\n  var fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    this.default(function() {\n      var arr = [];\n      if (fn) {\n        arr = defaultArr();\n      } else if (defaultArr != null) {\n        arr = defaultArr;\n      }\n      // Leave it up to `cast()` to convert the array\n      return arr;\n    });\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\n\n/**\n * Check if the given value satisfies a required validator. The given value\n * must be not null nor undefined, and have a non-zero length.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function(value) {\n  return !!(value && value.length);\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init) {\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      var indexes = doc.schema.indexedPaths();\n\n      for (var i = 0, l = indexes.length; i < l; ++i) {\n        var pathIndex = indexes[i][0][this.path];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this.path, doc);\n    }\n\n    if (this.caster) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          value[i] = this.caster.cast(value[i], doc, init);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);\n      }\n    }\n\n    return value;\n  }\n  // gh-2442: if we're loading this from the db and its not an array, mark\n  // the whole array as modified.\n  if (!!doc && !!init) {\n    doc.markModified(this.path);\n  }\n  return this.cast([value], doc, init);\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, value) {\n  var handler,\n      val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    var proto = this.casterConstructor.prototype;\n    var method = proto && (proto.castForQuery || proto.cast);\n    var caster = this.caster;\n\n    if (Array.isArray(val)) {\n      val = val.map(function(v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function(v) {\n    if (utils.isObject(v)) {\n      var o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n    return v;\n  }, this);\n\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  var keys = Object.keys(val);\n  var numKeys = keys.length;\n  var key;\n  var value;\n  for (var i = 0; i < numKeys; ++i) {\n    key = keys[i];\n    value = val[key];\n    if (key.indexOf('$') === 0 && value) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nvar handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = handle.$and = function(val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  var ret = [];\n  for (var i = 0; i < val.length; ++i) {\n    ret.push(cast(this.casterConstructor.schema, val[i]));\n  }\n\n  return ret;\n};\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$in =\nhandle.$lt =\nhandle.$lte =\nhandle.$ne =\nhandle.$nin =\nhandle.$regex = SchemaArray.prototype.castForQuery;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"]},"metadata":{},"sourceType":"script"}