{"ast":null,"code":"/*!\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\n\nvar MongooseError = require('./error');\n\nvar MixedSchema = require('./schema/mixed');\n\nvar Schema = require('./schema');\n\nvar ObjectExpectedError = require('./error/objectExpected');\n\nvar StrictModeError = require('./error/strict');\n\nvar ValidatorError = require('./schematype').ValidatorError;\n\nvar VersionError = require('./error').VersionError;\n\nvar utils = require('./utils');\n\nvar clone = utils.clone;\nvar isMongooseObject = utils.isMongooseObject;\n\nvar inspect = require('util').inspect;\n\nvar ValidationError = MongooseError.ValidationError;\n\nvar InternalCache = require('./internal');\n\nvar deepEqual = utils.deepEqual;\n\nvar hooks = require('hooks-fixed');\n\nvar PromiseProvider = require('./promise_provider');\n\nvar DocumentArray;\nvar MongooseArray;\nvar Embedded;\n\nvar flatten = require('./services/common').flatten;\n\nvar mpath = require('mpath');\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\n\nfunction Document(obj, fields, skipId) {\n  this.$__ = new InternalCache();\n  this.$__.emitter = new EventEmitter();\n  this.isNew = true;\n  this.errors = undefined;\n  var schema = this.schema;\n\n  if (typeof fields === 'boolean') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options && schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  var required = schema.requiredPaths(true);\n\n  for (var i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require(required[i]);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n  this._doc = this.$__buildDoc(obj, fields, skipId);\n\n  if (obj) {\n    if (obj instanceof Document) {\n      this.isNew = obj.isNew;\n    }\n\n    this.set(obj, undefined, true);\n  }\n\n  if (!schema.options.strict && obj) {\n    var _this = this,\n        keys = Object.keys(this._doc);\n\n    keys.forEach(function (key) {\n      if (!(key in schema.tree)) {\n        defineKey(key, null, _this);\n      }\n    });\n  }\n\n  this.$__registerHooksFromSchema();\n}\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\n\n\nutils.each(['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners', 'removeAllListeners', 'addListener'], function (emitterFn) {\n  Document.prototype[emitterFn] = function () {\n    return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n  };\n});\nDocument.prototype.constructor = Document;\n/**\n * The documents schema.\n *\n * @api public\n * @property schema\n */\n\nDocument.prototype.schema;\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n */\n\nDocument.prototype.isNew;\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n */\n\nDocument.prototype.id;\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n */\n\nDocument.prototype.errors;\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @return {Object}\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n */\n\nDocument.prototype.$__buildDoc = function (obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n\n  var _this = this; // determine if this doc is a result of a query with\n  // excluded fields\n\n\n  if (fields && utils.getFunctionName(fields.constructor) === 'Object') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === '_id') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== '_id' && (!fields[keys[ki]] || typeof fields[keys[ki]] !== 'object')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n  var hasIncludedChildren = {};\n\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split('.');\n      var c = [];\n\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join('.')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split('.');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = '';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n      curPath += (!curPath.length ? '' : '.') + piece; // support excluding intermediary levels\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n};\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb.\n *\n * @param {Object} doc document returned by mongo\n * @param {Function} fn callback\n * @api public\n */\n\n\nDocument.prototype.init = function (doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false; // handle docs with populated paths\n  // If doc._id is not null or undefined\n\n  if (doc._id !== null && doc._id !== undefined && opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n  this.emit('init', this);\n\n  if (fn) {\n    fn(null);\n  }\n\n  return this;\n};\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\n\nfunction init(self, obj, doc, prefix) {\n  prefix = prefix || '';\n  var keys = Object.keys(obj);\n  var len = keys.length;\n  var schema;\n  var path;\n  var i;\n  var index = 0;\n\n  if (self.schema.options.retainKeyOrder) {\n    while (index < len) {\n      _init(index++);\n    }\n  } else {\n    while (len--) {\n      _init(len);\n    }\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.schema.path(path);\n\n    if (!schema && utils.isObject(obj[i]) && (!obj[i].constructor || utils.getFunctionName(obj[i].constructor) === 'Object')) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n\n      init(self, obj[i], doc[i], path + '.');\n    } else {\n      if (obj[i] === null) {\n        doc[i] = null;\n      } else if (obj[i] !== undefined) {\n        if (schema) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      } // mark as hydrated\n\n\n      if (!self.isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n/**\n * Stores the current values of the shard keys.\n *\n * ####Note:\n *\n * _Shard key values do not / are not allowed to change._\n *\n * @api private\n * @method $__storeShard\n * @memberOf Document\n */\n\n\nDocument.prototype.$__storeShard = function () {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n\n  if (!(key && utils.getFunctionName(key.constructor) === 'Object')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({\n        depopulate: true,\n        _isNested: true\n      });\n    } else if (val !== null && val !== undefined && val.valueOf && ( // Explicitly don't take value of dates\n    !val.constructor || utils.getFunctionName(val.constructor) !== 'Date')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n};\n/*!\n * Set up middleware support\n */\n\n\nfor (var k in hooks) {\n  if (k === 'pre' || k === 'post') {\n    Document.prototype['$' + k] = Document['$' + k] = hooks[k];\n  } else {\n    Document.prototype[k] = Document[k] = hooks[k];\n  }\n}\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n */\n\n\nDocument.prototype.update = function update() {\n  var args = utils.args(arguments);\n  args.unshift({\n    _id: this._id\n  });\n  return this.constructor.update.apply(this.constructor, args);\n};\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n */\n\n\nDocument.prototype.set = function (path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === 'Object') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n  var strict = options && 'strict' in options ? options.strict : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val ? val + '.' : '';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null && path[key] !== void 0 // need to know if plain object - no Buffer, ObjectId, ref, etc\n    && utils.isObject(path[key]) && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === 'Object') && pathtype !== 'virtual' && pathtype !== 'real' && !(this.$__path(pathName) instanceof MixedSchema) && !(this.schema.paths[pathName] && this.schema.paths[pathName].options && this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don't overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 && this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === 'real' || pathtype === 'virtual') {\n        // Check for setting single embedded schema to document (gh-3535)\n        if (this.schema.paths[pathName] && this.schema.paths[pathName].$isSingleNested && path[key] instanceof Document) {\n          path[key] = path[key].toObject({\n            virtuals: false\n          });\n        }\n\n        this.set(prefix + key, path[key], constructing);\n      } else if (pathtype === 'nested' && path[key] instanceof Document) {\n        this.set(prefix + key, path[key].toObject({\n          transform: false\n        }), constructing);\n      } else if (strict === 'throw') {\n        if (pathtype === 'nested') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  } // ensure _strict is honored for obj props\n  // docschema = new Schema({ path: { nest: 'string' }})\n  // doc.set('path', obj);\n\n\n  var pathType = this.schema.pathType(path);\n\n  if (pathType === 'nested' && val) {\n    if (utils.isObject(val) && (!val.constructor || utils.getFunctionName(val.constructor) === 'Object')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n\n      return this;\n    }\n\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split('.');\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join('.');\n      schema = this.schema.path(subpath);\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      } // If path is underneath a virtual, bypass everything and just set it.\n\n\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark; // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join('.');\n\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n      // marked as dirty have precedence\n      || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  } // if this doc is being constructed we should not trigger getters\n\n\n  var priorVal = constructing ? undefined : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n\n    if (schema.options && schema.options.ref && val instanceof Document && schema.options.ref === val.constructor.modelName) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path), val._id, {\n          model: val.constructor\n        });\n      } else {\n        this.populated(path, val._id, {\n          model: val.constructor\n        });\n      }\n\n      didPopulate = true;\n    }\n\n    var popOpts;\n\n    if (schema.options && Array.isArray(schema.options.type) && schema.options.type.length && schema.options.type[0].ref && Array.isArray(val) && val.length > 0 && val[0] instanceof Document && val[0].constructor.modelName && schema.options.type[0].ref === val[0].constructor.modelName) {\n      if (this.ownerDocument) {\n        popOpts = {\n          model: val[0].constructor\n        };\n        this.ownerDocument().populated(this.$__fullPath(path), val.map(function (v) {\n          return v._id;\n        }), popOpts);\n      } else {\n        popOpts = {\n          model: val[0].constructor\n        };\n        this.populated(path, val.map(function (v) {\n          return v._id;\n        }), popOpts);\n      }\n\n      didPopulate = true;\n    }\n\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nfunction cleanModifiedSubpaths(doc, path) {\n  var _modifiedPaths = Object.keys(doc.$__.activePaths.states.modify);\n\n  var _numModifiedPaths = _modifiedPaths.length;\n\n  for (var j = 0; j < _numModifiedPaths; ++j) {\n    if (_modifiedPaths[j].indexOf(path + '.') === 0) {\n      delete doc.$__.activePaths.states.modify[_modifiedPaths[j]];\n    }\n  }\n}\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n */\n\n\nDocument.prototype.$__shouldModify = function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  } // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n\n\n  if (this.populated(path) && val instanceof Document && deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing && val !== null && val !== undefined && path in this.$__.activePaths.states.default && deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n\n  return false;\n};\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n */\n\n\nDocument.prototype.$__set = function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/embedded');\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts, schema, val, priorVal);\n\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val); // handle directly setting arrays (gh-1126)\n\n    MongooseArray || (MongooseArray = require('./types/array'));\n\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val); // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n\n\n      this.$__.activePaths.forEach(function (modifiedPath) {\n        if (modifiedPath.indexOf(path + '.') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = '';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += cur ? '.' + parts[i] : parts[i];\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === 'Object') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\n\nDocument.prototype.getValue = function (path) {\n  return utils.getValue(path, this._doc);\n};\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\n\nDocument.prototype.setValue = function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @api public\n */\n\n\nDocument.prototype.get = function (path, type) {\n  var adhoc;\n\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split('.'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0 ? undefined : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  } // Check if this path is populated - don't apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n\n\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n};\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n */\n\n\nDocument.prototype.$__path = function (path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n\n  return this.schema.path(path);\n};\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @api public\n */\n\n\nDocument.prototype.markModified = function (path) {\n  this.$__.activePaths.modify(path);\n};\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save() // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\n\nDocument.prototype.unmarkModified = function (path) {\n  this.$__.activePaths.init(path);\n};\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save() // changes to foo will not be persisted and validators won't be run\n *\n * @param {String} path the path to ignore\n * @api public\n */\n\n\nDocument.prototype.$ignore = function (path) {\n  this.$__.activePaths.ignore(path);\n};\n/**\n * Returns the list of paths that have been modified.\n *\n * @return {Array}\n * @api public\n */\n\n\nDocument.prototype.modifiedPaths = function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function (list, path) {\n    var parts = path.split('.');\n    return list.concat(parts.reduce(function (chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function (chain) {\n      return list.indexOf(chain) === -1;\n    }));\n  }, []);\n};\n/**\n * Returns true if this document was modified, else false.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isModified = function (paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function (path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function (path) {\n      return directModifiedPaths.some(function (mod) {\n        return mod === path || path.indexOf(mod + '.') === 0;\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     var m = new MyModel();\n *     m.$isDefault('name');               // true\n *\n * @param {String} [path]\n * @return {Boolean}\n * @method $isDefault\n * @api public\n */\n\n\nDocument.prototype.$isDefault = function (path) {\n  return path in this.$__.activePaths.states.default;\n};\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isDirectModified = function (path) {\n  return path in this.$__.activePaths.states.modify;\n};\n/**\n * Checks if `path` was initialized.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isInit = function (path) {\n  return path in this.$__.activePaths.states.init;\n};\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     Thing.findOne().select('name').exec(function (err, doc) {\n *        doc.isSelected('name') // true\n *        doc.isSelected('age')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected),\n        i = paths.length,\n        inclusive = false,\n        cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n\n      if (cur === '_id') {\n        continue;\n      }\n\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + '.';\n\n    while (i--) {\n      cur = paths[i];\n\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive;\n      }\n\n      if (pathDot.indexOf(cur + '.') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Object} optional options internal options\n * @param {Function} callback optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\n\nDocument.prototype.validate = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  this.$__validate(callback);\n};\n/*!\n * ignore\n */\n\n\nfunction _getPathsToValidate(doc) {\n  // only validate required fields when necessary\n  var paths = Object.keys(doc.$__.activePaths.states.require).filter(function (path) {\n    if (!doc.isSelected(path) && !doc.isModified(path)) {\n      return false;\n    }\n\n    var p = doc.schema.path(path);\n\n    if (typeof p.originalRequiredValue === 'function') {\n      return p.originalRequiredValue.call(doc);\n    }\n\n    return true;\n  });\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.init));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.modify));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.default)); // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n\n  for (var i = 0; i < paths.length; ++i) {\n    var path = paths[i];\n    var val = doc.getValue(path);\n\n    if (val && val.isMongooseArray && !Buffer.isBuffer(val) && !val.isMongooseDocumentArray) {\n      var numElements = val.length;\n\n      for (var j = 0; j < numElements; ++j) {\n        paths.push(path + '.' + j);\n      }\n    }\n  }\n\n  var flattenOptions = {\n    skipArrays: true\n  };\n\n  for (i = 0; i < paths.length; ++i) {\n    var pathToCheck = paths[i];\n\n    if (doc.schema.nested[pathToCheck]) {\n      var _v = doc.getValue(pathToCheck);\n\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({\n          transform: false\n        });\n      }\n\n      var flat = flatten(_v, '', flattenOptions);\n\n      var _subpaths = Object.keys(flat).map(function (p) {\n        return pathToCheck + '.' + p;\n      });\n\n      paths = paths.concat(_subpaths);\n    }\n  }\n\n  return paths;\n}\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__validate = function (callback) {\n  var _this = this;\n\n  var _complete = function () {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n\n    _this.emit('validate', _this);\n\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  }; // only validate required fields when necessary\n\n\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function () {\n      var err = _complete();\n\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function () {\n    var err = _complete();\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    callback();\n  };\n\n  var validatePath = function (path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n    process.nextTick(function () {\n      var p = _this.schema.path(path);\n\n      if (!p) {\n        return --total || complete();\n      } // If user marked as invalid or there was a cast error, don't validate\n\n\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n\n      p.doValidate(val, function (err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n};\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     var err = doc.validateSync();\n *     if ( err ){\n *       handleError( err );\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @return {MongooseError|undefined} MongooseError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\n\nDocument.prototype.validateSync = function (pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  } // only validate required fields when necessary\n\n\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n\n    paths = tmp;\n  }\n\n  var validating = {};\n  paths.forEach(function (path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n\n    if (!p) {\n      return;\n    }\n\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n\n    var err = p.doValidateSync(val, _this);\n\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n\n  _this.emit('validate', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\n\nDocument.prototype.invalidate = function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n};\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api private\n * @method $markValid\n * @receiver Document\n */\n\n\nDocument.prototype.$markValid = function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n/**\n * Checks if a path is invalid\n *\n * @param {String} path the field to check\n * @method $isValid\n * @api private\n * @receiver Document\n */\n\n\nDocument.prototype.$isValid = function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n};\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n */\n\n\nDocument.prototype.$__reset = function reset() {\n  var _this = this;\n\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  this.$__.activePaths.map('init', 'modify', function (i) {\n    return _this.getValue(i);\n  }).filter(function (val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).forEach(function (array) {\n    var i = array.length;\n\n    while (i--) {\n      var doc = array[i];\n\n      if (!doc) {\n        continue;\n      }\n\n      doc.$__reset();\n    }\n  }); // clear atomics\n\n  this.$__dirty().forEach(function (dirt) {\n    var type = dirt.value;\n\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  }); // Clear 'dirty' cache\n\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function (path) {\n    _this.$__.activePaths.require(path);\n  });\n  return this;\n};\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n */\n\n\nDocument.prototype.$__dirty = function () {\n  var _this = this;\n\n  var all = this.$__.activePaths.map('modify', function (path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }); // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n\n  all = all.concat(this.$__.activePaths.map('default', function (path) {\n    if (path === '_id' || !_this.getValue(path)) {\n      return;\n    }\n\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  })); // Sort dirty paths in a flat hierarchy.\n\n  all.sort(function (a, b) {\n    return a.path < b.path ? -1 : a.path > b.path ? 1 : 0;\n  }); // Ignore \"foo.a\" if \"foo\" is dirty already.\n\n  var minimal = [],\n      lastPath,\n      top;\n  all.forEach(function (item) {\n    if (!item) {\n      return;\n    }\n\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + '.';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n  top = lastPath = null;\n  return minimal;\n};\n/*!\n * Compiles schemas.\n */\n\n\nfunction compile(tree, proto, prefix, options) {\n  var keys = Object.keys(tree),\n      i = keys.length,\n      limb,\n      key;\n\n  while (i--) {\n    key = keys[i];\n    limb = tree[key];\n    defineKey(key, utils.getFunctionName(limb.constructor) === 'Object' && Object.keys(limb).length && (!limb[options.typeKey] || options.typeKey === 'type' && limb.type.type) ? limb : null, proto, prefix, keys, options);\n  }\n} // gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\n\n\nfunction getOwnPropertyDescriptors(object) {\n  var result = {};\n  Object.getOwnPropertyNames(object).forEach(function (key) {\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    result[key].enumerable = true;\n  });\n  return result;\n}\n/*!\n * Defines the accessor named prop on the incoming prototype.\n */\n\n\nfunction defineKey(prop, subprops, prototype, prefix, keys, options) {\n  var path = (prefix ? prefix + '.' : '') + prop;\n  prefix = prefix || '';\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n        var _this = this;\n\n        if (!this.$__.getters) {\n          this.$__.getters = {};\n        }\n\n        if (!this.$__.getters[path]) {\n          var nested = Object.create(Object.getPrototypeOf(this), getOwnPropertyDescriptors(this)); // save scope for nested getters/setters\n\n          if (!prefix) {\n            nested.$__.scope = this;\n          } // shadow inherited getters from sub-objects so\n          // thing.nested.nested.nested... doesn't occur (gh-366)\n\n\n          var i = 0,\n              len = keys.length;\n\n          for (; i < len; ++i) {\n            // over-write the parents getter without triggering it\n            Object.defineProperty(nested, keys[i], {\n              enumerable: false,\n              // It doesn't show up.\n              writable: true,\n              // We can set it later.\n              configurable: true,\n              // We can Object.defineProperty again.\n              value: undefined // It shadows its parent.\n\n            });\n          }\n\n          Object.defineProperty(nested, 'toObject', {\n            enumerable: true,\n            configurable: true,\n            writable: false,\n            value: function () {\n              return _this.get(path);\n            }\n          });\n          Object.defineProperty(nested, 'toJSON', {\n            enumerable: true,\n            configurable: true,\n            writable: false,\n            value: function () {\n              return _this.get(path);\n            }\n          });\n          Object.defineProperty(nested, '$__isNested', {\n            enumerable: true,\n            configurable: true,\n            writable: false,\n            value: true\n          });\n          compile(subprops, nested, path, options);\n          this.$__.getters[path] = nested;\n        }\n\n        return this.$__.getters[path];\n      },\n      set: function (v) {\n        if (v instanceof Document) {\n          v = v.toObject({\n            transform: false\n          });\n        }\n\n        return (this.$__.scope || this).set(path, v);\n      }\n    });\n  } else {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n        return this.get.call(this.$__.scope || this, path);\n      },\n      set: function (v) {\n        return this.set.call(this.$__.scope || this, path, v);\n      }\n    });\n  }\n}\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n */\n\n\nDocument.prototype.$__setSchema = function (schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n};\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n */\n\n\nDocument.prototype.$__getArrayPathsToValidate = function () {\n  DocumentArray || (DocumentArray = require('./types/documentarray')); // validate all document arrays.\n\n  return this.$__.activePaths.map('init', 'modify', function (i) {\n    return this.getValue(i);\n  }.bind(this)).filter(function (val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function (seed, array) {\n    return seed.concat(array);\n  }, []).filter(function (doc) {\n    return doc;\n  });\n};\n/**\n * Get all subdocs (by bfs)\n *\n * @api private\n * @method $__getAllSubdocs\n * @memberOf Document\n */\n\n\nDocument.prototype.$__getAllSubdocs = function () {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  Embedded = Embedded || require('./types/embedded');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      val = val.toObject();\n\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n  return subDocs;\n};\n/**\n * Executes methods queued from the Schema definition\n *\n * @api private\n * @method $__registerHooksFromSchema\n * @memberOf Document\n */\n\n\nDocument.prototype.$__registerHooksFromSchema = function () {\n  Embedded = Embedded || require('./types/embedded');\n  var Promise = PromiseProvider.get();\n\n  var _this = this;\n\n  var q = _this.schema && _this.schema.callQueue;\n\n  if (!q.length) {\n    return _this;\n  } // we are only interested in 'pre' hooks, and group by point-cut\n\n\n  var toWrap = q.reduce(function (seed, pair) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      _this[pair[0]].apply(_this, pair[1]);\n\n      return seed;\n    }\n\n    var args = [].slice.call(pair[1]);\n    var pointCut = pair[0] === 'on' ? 'post' : args[0];\n\n    if (!(pointCut in seed)) {\n      seed[pointCut] = {\n        post: [],\n        pre: []\n      };\n    }\n\n    if (pair[0] === 'post') {\n      seed[pointCut].post.push(args);\n    } else if (pair[0] === 'on') {\n      seed[pointCut].push(args);\n    } else {\n      seed[pointCut].pre.push(args);\n    }\n\n    return seed;\n  }, {\n    post: []\n  }); // 'post' hooks are simpler\n\n  toWrap.post.forEach(function (args) {\n    _this.on.apply(_this, args);\n  });\n  delete toWrap.post; // 'init' should be synchronous on subdocuments\n\n  if (toWrap.init && _this instanceof Embedded) {\n    if (toWrap.init.pre) {\n      toWrap.init.pre.forEach(function (args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n\n    if (toWrap.init.post) {\n      toWrap.init.post.forEach(function (args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n\n    delete toWrap.init;\n  } else if (toWrap.set) {\n    // Set hooks also need to be sync re: gh-3479\n    if (toWrap.set.pre) {\n      toWrap.set.pre.forEach(function (args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n\n    if (toWrap.set.post) {\n      toWrap.set.post.forEach(function (args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n\n    delete toWrap.set;\n  }\n\n  Object.keys(toWrap).forEach(function (pointCut) {\n    // this is so we can wrap everything into a promise;\n    var newName = '$__original_' + pointCut;\n\n    if (!_this[pointCut]) {\n      return;\n    }\n\n    _this[newName] = _this[pointCut];\n\n    _this[pointCut] = function wrappedPointCut() {\n      var args = [].slice.call(arguments);\n      var lastArg = args.pop();\n      var fn;\n      var originalError = new Error();\n      var $results;\n\n      if (lastArg && typeof lastArg !== 'function') {\n        args.push(lastArg);\n      } else {\n        fn = lastArg;\n      }\n\n      var promise = new Promise.ES6(function (resolve, reject) {\n        args.push(function (error) {\n          if (error) {\n            // gh-2633: since VersionError is very generic, take the\n            // stack trace of the original save() function call rather\n            // than the async trace\n            if (error instanceof VersionError) {\n              error.stack = originalError.stack;\n            }\n\n            _this.$__handleReject(error);\n\n            reject(error);\n            return;\n          } // There may be multiple results and promise libs other than\n          // mpromise don't support passing multiple values to `resolve()`\n\n\n          $results = Array.prototype.slice.call(arguments, 1);\n          resolve.apply(promise, $results);\n        });\n\n        _this[newName].apply(_this, args);\n      });\n\n      if (fn) {\n        if (_this.constructor.$wrapCallback) {\n          fn = _this.constructor.$wrapCallback(fn);\n        }\n\n        return promise.then(function () {\n          process.nextTick(function () {\n            fn.apply(null, [null].concat($results));\n          });\n        }, function (error) {\n          process.nextTick(function () {\n            fn(error);\n          });\n        });\n      }\n\n      return promise;\n    };\n\n    toWrap[pointCut].pre.forEach(function (args) {\n      args[0] = newName;\n\n      _this.$pre.apply(_this, args);\n    });\n    toWrap[pointCut].post.forEach(function (args) {\n      args[0] = newName;\n\n      _this.$post.apply(_this, args);\n    });\n  });\n  return _this;\n};\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners('error').length) {\n    this.emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  } else if (this.listeners && this.listeners('error').length) {\n    this.emit('error', err);\n  }\n};\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n */\n\n\nDocument.prototype.$toObject = function (options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder\n  }; // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  } // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n\n\n  if (!(options && utils.getFunctionName(options.constructor) === 'Object') || options && options._useSchemaOptions) {\n    if (json) {\n      options = this.schema.options.toJSON ? clone(this.schema.options.toJSON) : {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ? clone(this.schema.options.toObject) : {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  'minimize' in options || (options.minimize = this.schema.options.minimize); // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n\n  var originalTransform = options.transform;\n  options._isNested = true;\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, 'paths', options); // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, 'virtuals', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform; // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n\n  if (transform === true || this.schema.options.toObject && transform) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = typeof options.transform === 'function' ? options.transform : opts.transform;\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    var xformed = transform(this, ret, options);\n\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n/**\n * Converts this document into a plain javascript object, ready for storage in MongoDB.\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters)\n * - `virtuals` apply virtual getters (can override `getters` option)\n * - `minimize` remove empty objects (defaults to true)\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)\n * - `versionKey` whether to include the version key (defaults to true)\n * - `retainKeyOrder` keep the order of object keys. If this is set to true, `Object.keys(new Doc({ a: 1, b: 2}).toObject())` will always produce `['a', 'b']` (defaults to false)\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * _Note: if you call `toObject` and pass any options, the transform declared in your schema options will __not__ be applied. To force its application pass `transform: true`_\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     var doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id' });                  // { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * Transforms are applied _only to the document and are not applied to sub-documents_.\n *\n * Transforms, like all of these options, are also available for `toJSON`.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n */\n\n\nDocument.prototype.toObject = function (options) {\n  return this.$toObject(options);\n};\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\n\nfunction minimize(obj) {\n  var keys = Object.keys(obj),\n      i = keys.length,\n      hasKeys,\n      key,\n      val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isObject(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys ? obj : undefined;\n}\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @param {String} type either `virtuals` or `paths`\n * @return {Object} `json`\n */\n\n\nfunction applyGetters(self, json, type, options) {\n  var schema = self.schema,\n      paths = Object.keys(schema[type]),\n      i = paths.length,\n      path;\n\n  while (i--) {\n    path = paths[i];\n    var parts = path.split('.'),\n        plen = parts.length,\n        last = plen - 1,\n        branch = json,\n        part;\n\n    for (var ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n\n      if (ii === last) {\n        branch[part] = clone(self.get(path), options);\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n    }\n  }\n\n  return json;\n}\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @api public\n */\n\n\nDocument.prototype.toJSON = function (options) {\n  return this.$toObject(options, true);\n};\n/**\n * Helper for console.log\n *\n * @api public\n */\n\n\nDocument.prototype.inspect = function (options) {\n  var isPOJO = options && utils.getFunctionName(options.constructor) === 'Object';\n  var opts;\n\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n\n  return this.toObject(opts);\n};\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n */\n\n\nDocument.prototype.toString = function () {\n  return inspect(this.inspect());\n};\n/**\n * Returns true if the Document stores the same data as doc.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.equals = function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get('_id');\n  var docid = doc.get ? doc.get('_id') : doc;\n\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n\n  return tid && tid.equals ? tid.equals(docid) : tid === docid;\n};\n/**\n * Populates document references, executing the `callback` when complete.\n * If you want to use promises instead, use this function with\n * [`execPopulate()`](#document_Document-execPopulate)\n *\n * ####Example:\n *\n *     doc\n *     .populate('company')\n *     .populate({\n *       path: 'notes',\n *       match: /airline/,\n *       select: 'text',\n *       model: 'modelName'\n *       options: opts\n *     }, function (err, user) {\n *       assert(doc._id === user._id) // the document itself is passed\n *     })\n *\n *     // summary\n *     doc.populate(path)                   // not executed\n *     doc.populate(options);               // not executed\n *     doc.populate(path, callback)         // executed\n *     doc.populate(options, callback);     // executed\n *     doc.populate(callback);              // executed\n *     doc.populate(options).execPopulate() // executed, returns promise\n *\n *\n * ####NOTE:\n *\n * Population does not occur unless a `callback` is passed *or* you explicitly\n * call `execPopulate()`.\n * Passing the same path a second time will overwrite the previous path options.\n * See [Model.populate()](#model_Model.populate) for explaination of options.\n *\n * @see Model.populate #model_Model.populate\n * @see Document.execPopulate #document_Document-execPopulate\n * @param {String|Object} [path] The path to populate or an options object\n * @param {Function} [callback] When passed, population is invoked\n * @api public\n * @return {Document} this\n */\n\n\nDocument.prototype.populate = function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === 'function') {\n    fn = args.pop();\n  } // allow `doc.populate(callback)`\n\n\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n};\n/**\n * Explicitly executes population and returns a promise. Useful for ES2015\n * integration.\n *\n * ####Example:\n *\n *     var promise = doc.\n *       populate('company').\n *       populate({\n *         path: 'notes',\n *         match: /airline/,\n *         select: 'text',\n *         model: 'modelName'\n *         options: opts\n *       }).\n *       execPopulate();\n *\n *     // summary\n *     doc.execPopulate().then(resolve, reject);\n *\n *\n * @see Document.populate #document_Document-populate\n * @api public\n * @return {Promise} promise that resolves to the document when population is done\n */\n\n\nDocument.prototype.execPopulate = function () {\n  var Promise = PromiseProvider.get();\n\n  var _this = this;\n\n  return new Promise.ES6(function (resolve, reject) {\n    _this.populate(function (error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n};\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, undefined is returned.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @api public\n */\n\n\nDocument.prototype.populated = function (path, val, options) {\n  // val and options are internal\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n\n    var v = this.$__.populated[path];\n\n    if (v) {\n      return v.value;\n    }\n\n    return undefined;\n  } // internal\n\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {\n    value: val,\n    options: options\n  };\n  return val;\n};\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, this is a no-op.\n *\n * @param {String} path\n * @see Document.populate #document_Document-populate\n * @api public\n */\n\n\nDocument.prototype.depopulate = function (path) {\n  var populatedIds = this.populated(path);\n\n  if (!populatedIds) {\n    return;\n  }\n\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n};\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n */\n\n\nDocument.prototype.$__fullPath = function (path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n/*!\n * Module exports.\n */\n\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;","map":{"version":3,"sources":["C:/Users/SATAN/darelist/client/node_modules/mongoose/lib/document.js"],"names":["EventEmitter","require","MongooseError","MixedSchema","Schema","ObjectExpectedError","StrictModeError","ValidatorError","VersionError","utils","clone","isMongooseObject","inspect","ValidationError","InternalCache","deepEqual","hooks","PromiseProvider","DocumentArray","MongooseArray","Embedded","flatten","mpath","Document","obj","fields","skipId","$__","emitter","isNew","errors","undefined","schema","strictMode","options","strict","selected","required","requiredPaths","i","length","activePaths","setMaxListeners","_doc","$__buildDoc","set","_this","keys","Object","forEach","key","tree","defineKey","$__registerHooksFromSchema","each","emitterFn","prototype","apply","arguments","constructor","id","doc","exclude","ki","getFunctionName","paths","plen","ii","hasIncludedChildren","j","parts","split","c","k","push","join","p","type","path","len","last","curPath","doc_","included","piece","def","getDefault","default","init","opts","fn","_id","populated","String","item","isVirtual","getValue","_docs","$__storeShard","emit","self","prefix","index","retainKeyOrder","_init","isObject","cast","e","invalidate","message","value","isModified","shardKey","shardkey","orig","shardval","val","toObject","depopulate","_isNested","valueOf","update","args","unshift","merge","adhoc","constructing","adhocs","adhocPaths","interpretAsType","_","$__isNested","pathtype","minimize","_handleIndex","call","pathName","pathType","$__path","ref","get","$isSingleNested","virtuals","transform","setValue","cleanModifiedSubpaths","markModified","CastError","mixed","subpath","slice","virtualpath","applySetters","pathToMark","isDirectModified","priorVal","$__set","shouldSet","didPopulate","modelName","ownerDocument","$__fullPath","model","popOpts","Array","isArray","map","v","$markValid","instance","_modifiedPaths","states","modify","_numModifiedPaths","indexOf","$__shouldModify","isSelected","shouldModify","isMongooseArray","_registerAtomic","modifiedPath","ignore","l","cur","next","pieces","applyGetters","adhocType","unmarkModified","$ignore","modifiedPaths","directModifiedPaths","reduce","list","concat","chains","part","filter","chain","modified","isModifiedChild","some","mod","$isDefault","isInit","inclusive","pathDot","validate","callback","$__validate","_getPathsToValidate","originalRequiredValue","Buffer","isBuffer","isMongooseDocumentArray","numElements","flattenOptions","skipArrays","pathToCheck","nested","_v","flat","_subpaths","_complete","err","validationError","__parent","process","nextTick","validating","total","complete","validatePath","$isValid","doValidate","validateSync","pathsToValidate","tmp","doValidateSync","kind","$__reset","reset","array","$__dirty","dirt","_atomics","clear","all","sort","a","b","minimal","lastPath","top","hasAtomics","$set","compile","proto","limb","typeKey","getOwnPropertyDescriptors","object","result","getOwnPropertyNames","getOwnPropertyDescriptor","enumerable","prop","subprops","defineProperty","configurable","getters","create","getPrototypeOf","scope","writable","$__setSchema","$__getArrayPathsToValidate","bind","seed","$__getAllSubdocs","docReducer","_docReduce","subDocs","Promise","q","callQueue","toWrap","pair","pointCut","post","pre","on","$pre","$post","newName","wrappedPointCut","lastArg","pop","originalError","Error","$results","promise","ES6","resolve","reject","error","stack","$__handleReject","$wrapCallback","then","handleReject","listeners","$toObject","json","defaultOptions","wasPopulated","_useSchemaOptions","toJSON","originalTransform","ret","versionKey","xformed","hasKeys","branch","isPOJO","toString","equals","tid","docid","populate","res","vals","__noPromise","execPopulate","populatedIds","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar MongooseError = require('./error');\nvar MixedSchema = require('./schema/mixed');\nvar Schema = require('./schema');\nvar ObjectExpectedError = require('./error/objectExpected');\nvar StrictModeError = require('./error/strict');\nvar ValidatorError = require('./schematype').ValidatorError;\nvar VersionError = require('./error').VersionError;\nvar utils = require('./utils');\nvar clone = utils.clone;\nvar isMongooseObject = utils.isMongooseObject;\nvar inspect = require('util').inspect;\nvar ValidationError = MongooseError.ValidationError;\nvar InternalCache = require('./internal');\nvar deepEqual = utils.deepEqual;\nvar hooks = require('hooks-fixed');\nvar PromiseProvider = require('./promise_provider');\nvar DocumentArray;\nvar MongooseArray;\nvar Embedded;\nvar flatten = require('./services/common').flatten;\nvar mpath = require('mpath');\n\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId) {\n  this.$__ = new InternalCache;\n  this.$__.emitter = new EventEmitter();\n  this.isNew = true;\n  this.errors = undefined;\n\n  var schema = this.schema;\n\n  if (typeof fields === 'boolean') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options && schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  var required = schema.requiredPaths(true);\n  for (var i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require(required[i]);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n  this._doc = this.$__buildDoc(obj, fields, skipId);\n\n  if (obj) {\n    if (obj instanceof Document) {\n      this.isNew = obj.isNew;\n    }\n    this.set(obj, undefined, true);\n  }\n\n  if (!schema.options.strict && obj) {\n    var _this = this,\n        keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      if (!(key in schema.tree)) {\n        defineKey(key, null, _this);\n      }\n    });\n  }\n\n  this.$__registerHooksFromSchema();\n}\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n    ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n      'removeAllListeners', 'addListener'],\n    function(emitterFn) {\n      Document.prototype[emitterFn] = function() {\n        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n      };\n    });\n\nDocument.prototype.constructor = Document;\n\n/**\n * The documents schema.\n *\n * @api public\n * @property schema\n */\n\nDocument.prototype.schema;\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n */\n\nDocument.prototype.isNew;\n\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n */\n\nDocument.prototype.errors;\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @return {Object}\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId) {\n  var doc = {};\n  var exclude = null;\n  var keys;\n  var ki;\n  var _this = this;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (fields && utils.getFunctionName(fields.constructor) === 'Object') {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    if (ki === 1 && keys[0] === '_id') {\n      exclude = !!fields[keys[ki]];\n    } else {\n      while (ki--) {\n        if (keys[ki] !== '_id' &&\n            (!fields[keys[ki]] || typeof fields[keys[ki]] !== 'object')) {\n          exclude = !fields[keys[ki]];\n          break;\n        }\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths);\n  var plen = paths.length;\n  var ii = 0;\n\n  var hasIncludedChildren = {};\n  if (exclude === false && fields) {\n    keys = Object.keys(fields);\n    for (var j = 0; j < keys.length; ++j) {\n      var parts = keys[j].split('.');\n      var c = [];\n      for (var k = 0; k < parts.length; ++k) {\n        c.push(parts[k]);\n        hasIncludedChildren[c.join('.')] = 1;\n      }\n    }\n  }\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    var type = this.schema.paths[p];\n    var path = p.split('.');\n    var len = path.length;\n    var last = len - 1;\n    var curPath = '';\n    var doc_ = doc;\n    var i = 0;\n    var included = false;\n\n    for (; i < len; ++i) {\n      var piece = path[i],\n          def;\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i === last) {\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(_this, false);\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(_this, false);\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              _this.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(_this, false);\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            _this.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  return doc;\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb.\n *\n * @param {Object} doc document returned by mongo\n * @param {Function} fn callback\n * @api public\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  // do not prefix this method with $__ since its\n  // used by public hooks\n\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.isNew = false;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    var id = String(doc._id);\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n  this.$__storeShard();\n\n  this.emit('init', this);\n  if (fn) {\n    fn(null);\n  }\n  return this;\n};\n\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\nfunction init(self, obj, doc, prefix) {\n  prefix = prefix || '';\n\n  var keys = Object.keys(obj);\n  var len = keys.length;\n  var schema;\n  var path;\n  var i;\n  var index = 0;\n\n  if (self.schema.options.retainKeyOrder) {\n    while (index < len) {\n      _init(index++);\n    }\n  } else {\n    while (len--) {\n      _init(len);\n    }\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.schema.path(path);\n\n    if (!schema && utils.isObject(obj[i]) &&\n        (!obj[i].constructor || utils.getFunctionName(obj[i].constructor) === 'Object')) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n      init(self, obj[i], doc[i], path + '.');\n    } else {\n      if (obj[i] === null) {\n        doc[i] = null;\n      } else if (obj[i] !== undefined) {\n        if (schema) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Stores the current values of the shard keys.\n *\n * ####Note:\n *\n * _Shard key values do not / are not allowed to change._\n *\n * @api private\n * @method $__storeShard\n * @memberOf Document\n */\n\nDocument.prototype.$__storeShard = function() {\n  // backwards compat\n  var key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === 'Object')) {\n    return;\n  }\n\n  var orig = this.$__.shardval = {},\n      paths = Object.keys(key),\n      len = paths.length,\n      val;\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n          // Explicitly don't take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== 'Date')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n};\n\n/*!\n * Set up middleware support\n */\n\nfor (var k in hooks) {\n  if (k === 'pre' || k === 'post') {\n    Document.prototype['$' + k] = Document['$' + k] = hooks[k];\n  } else {\n    Document.prototype[k] = Document[k] = hooks[k];\n  }\n}\n\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n */\n\nDocument.prototype.update = function update() {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n};\n\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n */\n\nDocument.prototype.set = function(path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === 'Object') {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge,\n      adhoc = type && type !== true,\n      constructing = type === true,\n      adhocs;\n\n  var strict = options && 'strict' in options\n      ? options.strict\n      : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== 'string') {\n    // new Document({ key: val })\n\n    if (path === null || path === void 0) {\n      var _ = path;\n      path = val;\n      val = _;\n    } else {\n      var prefix = val\n          ? val + '.'\n          : '';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      var keys = Object.keys(path);\n      var len = keys.length;\n      var i = 0;\n      var pathtype;\n      var key;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.set(val, {});\n        }\n        return this;\n      }\n\n      if (this.schema.options.retainKeyOrder) {\n        while (i < len) {\n          _handleIndex.call(this, i++);\n        }\n      } else {\n        while (len--) {\n          _handleIndex.call(this, len);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    var pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    if (path[key] !== null\n        && path[key] !== void 0\n          // need to know if plain object - no Buffer, ObjectId, ref, etc\n        && utils.isObject(path[key])\n        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === 'Object')\n        && pathtype !== 'virtual'\n        && pathtype !== 'real'\n        && !(this.$__path(pathName) instanceof MixedSchema)\n        && !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don't overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === 'real' || pathtype === 'virtual') {\n        // Check for setting single embedded schema to document (gh-3535)\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          path[key] = path[key].toObject({virtuals: false});\n        }\n        this.set(prefix + key, path[key], constructing);\n      } else if (pathtype === 'nested' && path[key] instanceof Document) {\n        this.set(prefix + key,\n            path[key].toObject({transform: false}), constructing);\n      } else if (strict === 'throw') {\n        if (pathtype === 'nested') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.set(prefix + key, path[key], constructing);\n    }\n  }\n\n  // ensure _strict is honored for obj props\n  // docschema = new Schema({ path: { nest: 'string' }})\n  // doc.set('path', obj);\n  var pathType = this.schema.pathType(path);\n  if (pathType === 'nested' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === 'Object')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      }\n\n      if (Object.keys(val).length === 0) {\n        this.setValue(path, {});\n        this.markModified(path);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        this.set(val, path, constructing);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  var schema;\n  var parts = path.split('.');\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      var subpath = parts.slice(0, i + 1).join('.');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n    }\n\n    if (!mixed) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i + 1).join('.');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n            // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n      ? undefined\n      : this.getValue(path);\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    var didPopulate = false;\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        schema.options.ref === val.constructor.modelName) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    var popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options.type) &&\n        schema.options.type.length &&\n        schema.options.type[0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        schema.options.type[0].ref === val[0].constructor.modelName) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction cleanModifiedSubpaths(doc, path) {\n  var _modifiedPaths = Object.keys(doc.$__.activePaths.states.modify);\n  var _numModifiedPaths = _modifiedPaths.length;\n  for (var j = 0; j < _numModifiedPaths; ++j) {\n    if (_modifiedPaths[j].indexOf(path + '.') === 0) {\n      delete doc.$__.activePaths.states.modify[_modifiedPaths[j]];\n    }\n  }\n}\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (undefined === val && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n */\n\nDocument.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/embedded');\n\n  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  var _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val);\n\n      // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + '.') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  var obj = this._doc;\n  var i = 0;\n  var l = parts.length;\n  var cur = '';\n\n  for (; i < l; i++) {\n    var next = i + 1;\n    var last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === 'Object') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        this.set(cur, {});\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\nDocument.prototype.getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\nDocument.prototype.setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @api public\n */\n\nDocument.prototype.get = function(path, type) {\n  var adhoc;\n  if (type) {\n    adhoc = Schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path),\n      pieces = path.split('.'),\n      obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = obj === null || obj === void 0\n        ? undefined\n        : obj[pieces[i]];\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  // Check if this path is populated - don't apply getters if it is,\n  // because otherwise its a nested object. See gh-3357\n  if (schema && !this.populated(path)) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n};\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n */\n\nDocument.prototype.$__path = function(path) {\n  var adhocs = this.$__.adhocPaths,\n      adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @api public\n */\n\nDocument.prototype.markModified = function(path) {\n  this.$__.activePaths.modify(path);\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save() // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save() // changes to foo will not be persisted and validators won't be run\n *\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function() {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  return directModifiedPaths.reduce(function(list, path) {\n    var parts = path.split('.');\n    return list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n  }, []);\n};\n\n/**\n * Returns true if this document was modified, else false.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n    var modified = this.modifiedPaths();\n    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    var isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + '.') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some('modify');\n};\n\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     var m = new MyModel();\n *     m.$isDefault('name');               // true\n *\n * @param {String} [path]\n * @return {Boolean}\n * @method $isDefault\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  return (path in this.$__.activePaths.states.default);\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  return (path in this.$__.activePaths.states.modify);\n};\n\n/**\n * Checks if `path` was initialized.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  return (path in this.$__.activePaths.states.init);\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     Thing.findOne().select('name').exec(function (err, doc) {\n *        doc.isSelected('name') // true\n *        doc.isSelected('age')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    var paths = Object.keys(this.$__.selected),\n        i = paths.length,\n        inclusive = false,\n        cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + '.';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive;\n      }\n\n      if (pathDot.indexOf(cur + '.') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Object} optional options internal options\n * @param {Function} callback optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\nDocument.prototype.validate = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  this.$__validate(callback);\n};\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc) {\n  // only validate required fields when necessary\n  var paths = Object.keys(doc.$__.activePaths.states.require).filter(function(path) {\n    if (!doc.isSelected(path) && !doc.isModified(path)) {\n      return false;\n    }\n    var p = doc.schema.path(path);\n    if (typeof p.originalRequiredValue === 'function') {\n      return p.originalRequiredValue.call(doc);\n    }\n    return true;\n  });\n\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.init));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.modify));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.default));\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (var i = 0; i < paths.length; ++i) {\n    var path = paths[i];\n    var val = doc.getValue(path);\n    if (val && val.isMongooseArray && !Buffer.isBuffer(val) && !val.isMongooseDocumentArray) {\n      var numElements = val.length;\n      for (var j = 0; j < numElements; ++j) {\n        paths.push(path + '.' + j);\n      }\n    }\n  }\n\n  var flattenOptions = { skipArrays: true };\n  for (i = 0; i < paths.length; ++i) {\n    var pathToCheck = paths[i];\n    if (doc.schema.nested[pathToCheck]) {\n      var _v = doc.getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      var flat = flatten(_v, '', flattenOptions);\n      var _subpaths = Object.keys(flat).map(function(p) {\n        return pathToCheck + '.' + p;\n      });\n      paths = paths.concat(_subpaths);\n    }\n  }\n\n  return paths;\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(callback) {\n  var _this = this;\n  var _complete = function() {\n    var err = _this.$__.validationError;\n    _this.$__.validationError = undefined;\n    _this.emit('validate', _this);\n    if (err) {\n      for (var key in err.errors) {\n        // Make sure cast errors persist\n        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          _this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (paths.length === 0) {\n    process.nextTick(function() {\n      var err = _complete();\n      if (err) {\n        callback(err);\n        return;\n      }\n      callback();\n    });\n  }\n\n  var validating = {},\n      total = 0;\n\n  var complete = function() {\n    var err = _complete();\n    if (err) {\n      callback(err);\n      return;\n    }\n    callback();\n  };\n\n  var validatePath = function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      var p = _this.schema.path(path);\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      var val = _this.getValue(path);\n      p.doValidate(val, function(err) {\n        if (err) {\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, _this);\n    });\n  };\n\n  paths.forEach(validatePath);\n};\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     var err = doc.validateSync();\n *     if ( err ){\n *       handleError( err );\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @return {MongooseError|undefined} MongooseError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate) {\n  var _this = this;\n\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n\n  // only validate required fields when necessary\n  var paths = _getPathsToValidate(this);\n\n  if (pathsToValidate && pathsToValidate.length) {\n    var tmp = [];\n    for (var i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  var validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    var p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    var val = _this.getValue(path);\n    var err = p.doValidateSync(val, _this);\n    if (err) {\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  var err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit('validate', _this);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.errors[path] = err;\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api private\n * @method $markValid\n * @receiver Document\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/**\n * Checks if a path is invalid\n *\n * @param {String} path the field to check\n * @method $isValid\n * @api private\n * @receiver Document\n */\n\nDocument.prototype.$isValid = function(path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n */\n\nDocument.prototype.$__reset = function reset() {\n  var _this = this;\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  this.$__.activePaths\n  .map('init', 'modify', function(i) {\n    return _this.getValue(i);\n  })\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  })\n  .forEach(function(array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) {\n        continue;\n      }\n      doc.$__reset();\n    }\n  });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n */\n\nDocument.prototype.$__dirty = function() {\n  var _this = this;\n\n  var all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || !_this.getValue(path)) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  var minimal = [],\n      lastPath,\n      top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + '.';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n};\n\n/*!\n * Compiles schemas.\n */\n\nfunction compile(tree, proto, prefix, options) {\n  var keys = Object.keys(tree),\n      i = keys.length,\n      limb,\n      key;\n\n  while (i--) {\n    key = keys[i];\n    limb = tree[key];\n\n    defineKey(key,\n        ((utils.getFunctionName(limb.constructor) === 'Object'\n        && Object.keys(limb).length)\n        && (!limb[options.typeKey] || (options.typeKey === 'type' && limb.type.type))\n            ? limb\n            : null)\n        , proto\n        , prefix\n        , keys\n        , options);\n  }\n}\n\n// gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\nfunction getOwnPropertyDescriptors(object) {\n  var result = {};\n\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    result[key].enumerable = true;\n  });\n\n  return result;\n}\n\n/*!\n * Defines the accessor named prop on the incoming prototype.\n */\n\nfunction defineKey(prop, subprops, prototype, prefix, keys, options) {\n  var path = (prefix ? prefix + '.' : '') + prop;\n  prefix = prefix || '';\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        var _this = this;\n        if (!this.$__.getters) {\n          this.$__.getters = {};\n        }\n\n        if (!this.$__.getters[path]) {\n          var nested = Object.create(Object.getPrototypeOf(this), getOwnPropertyDescriptors(this));\n\n          // save scope for nested getters/setters\n          if (!prefix) {\n            nested.$__.scope = this;\n          }\n\n          // shadow inherited getters from sub-objects so\n          // thing.nested.nested.nested... doesn't occur (gh-366)\n          var i = 0,\n              len = keys.length;\n\n          for (; i < len; ++i) {\n            // over-write the parents getter without triggering it\n            Object.defineProperty(nested, keys[i], {\n              enumerable: false,    // It doesn't show up.\n              writable: true,       // We can set it later.\n              configurable: true,   // We can Object.defineProperty again.\n              value: undefined      // It shadows its parent.\n            });\n          }\n\n          Object.defineProperty(nested, 'toObject', {\n            enumerable: true,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path);\n            }\n          });\n\n          Object.defineProperty(nested, 'toJSON', {\n            enumerable: true,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path);\n            }\n          });\n\n          Object.defineProperty(nested, '$__isNested', {\n            enumerable: true,\n            configurable: true,\n            writable: false,\n            value: true\n          });\n\n          compile(subprops, nested, path, options);\n          this.$__.getters[path] = nested;\n        }\n\n        return this.$__.getters[path];\n      },\n      set: function(v) {\n        if (v instanceof Document) {\n          v = v.toObject({ transform: false });\n        }\n        return (this.$__.scope || this).set(path, v);\n      }\n    });\n  } else {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        return this.get.call(this.$__.scope || this, path);\n      },\n      set: function(v) {\n        return this.set.call(this.$__.scope || this, path, v);\n      }\n    });\n  }\n}\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  compile(schema.tree, this, undefined, schema.options);\n  this.schema = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n  .map('init', 'modify', function(i) {\n    return this.getValue(i);\n  }.bind(this))\n  .filter(function(val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function(seed, array) {\n    return seed.concat(array);\n  }, [])\n  .filter(function(doc) {\n    return doc;\n  });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @api private\n * @method $__getAllSubdocs\n * @memberOf Document\n */\n\nDocument.prototype.$__getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  Embedded = Embedded || require('./types/embedded');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(docReducer.bind(val._doc), seed);\n      seed.push(val);\n    }\n    if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      val = val.toObject();\n      if (val) {\n        seed = Object.keys(val).reduce(docReducer.bind(val), seed);\n      }\n    }\n    return seed;\n  }\n\n  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);\n\n  return subDocs;\n};\n\n/**\n * Executes methods queued from the Schema definition\n *\n * @api private\n * @method $__registerHooksFromSchema\n * @memberOf Document\n */\n\nDocument.prototype.$__registerHooksFromSchema = function() {\n  Embedded = Embedded || require('./types/embedded');\n  var Promise = PromiseProvider.get();\n\n  var _this = this;\n  var q = _this.schema && _this.schema.callQueue;\n  if (!q.length) {\n    return _this;\n  }\n\n  // we are only interested in 'pre' hooks, and group by point-cut\n  var toWrap = q.reduce(function(seed, pair) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      _this[pair[0]].apply(_this, pair[1]);\n      return seed;\n    }\n    var args = [].slice.call(pair[1]);\n    var pointCut = pair[0] === 'on' ? 'post' : args[0];\n    if (!(pointCut in seed)) {\n      seed[pointCut] = {post: [], pre: []};\n    }\n    if (pair[0] === 'post') {\n      seed[pointCut].post.push(args);\n    } else if (pair[0] === 'on') {\n      seed[pointCut].push(args);\n    } else {\n      seed[pointCut].pre.push(args);\n    }\n    return seed;\n  }, {post: []});\n\n  // 'post' hooks are simpler\n  toWrap.post.forEach(function(args) {\n    _this.on.apply(_this, args);\n  });\n  delete toWrap.post;\n\n  // 'init' should be synchronous on subdocuments\n  if (toWrap.init && _this instanceof Embedded) {\n    if (toWrap.init.pre) {\n      toWrap.init.pre.forEach(function(args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n    if (toWrap.init.post) {\n      toWrap.init.post.forEach(function(args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n    delete toWrap.init;\n  } else if (toWrap.set) {\n    // Set hooks also need to be sync re: gh-3479\n    if (toWrap.set.pre) {\n      toWrap.set.pre.forEach(function(args) {\n        _this.$pre.apply(_this, args);\n      });\n    }\n    if (toWrap.set.post) {\n      toWrap.set.post.forEach(function(args) {\n        _this.$post.apply(_this, args);\n      });\n    }\n    delete toWrap.set;\n  }\n\n  Object.keys(toWrap).forEach(function(pointCut) {\n    // this is so we can wrap everything into a promise;\n    var newName = ('$__original_' + pointCut);\n    if (!_this[pointCut]) {\n      return;\n    }\n    _this[newName] = _this[pointCut];\n    _this[pointCut] = function wrappedPointCut() {\n      var args = [].slice.call(arguments);\n      var lastArg = args.pop();\n      var fn;\n      var originalError = new Error();\n      var $results;\n      if (lastArg && typeof lastArg !== 'function') {\n        args.push(lastArg);\n      } else {\n        fn = lastArg;\n      }\n\n      var promise = new Promise.ES6(function(resolve, reject) {\n        args.push(function(error) {\n          if (error) {\n            // gh-2633: since VersionError is very generic, take the\n            // stack trace of the original save() function call rather\n            // than the async trace\n            if (error instanceof VersionError) {\n              error.stack = originalError.stack;\n            }\n            _this.$__handleReject(error);\n            reject(error);\n            return;\n          }\n\n          // There may be multiple results and promise libs other than\n          // mpromise don't support passing multiple values to `resolve()`\n          $results = Array.prototype.slice.call(arguments, 1);\n          resolve.apply(promise, $results);\n        });\n\n        _this[newName].apply(_this, args);\n      });\n      if (fn) {\n        if (_this.constructor.$wrapCallback) {\n          fn = _this.constructor.$wrapCallback(fn);\n        }\n        return promise.then(\n          function() {\n            process.nextTick(function() {\n              fn.apply(null, [null].concat($results));\n            });\n          },\n          function(error) {\n            process.nextTick(function() {\n              fn(error);\n            });\n          });\n      }\n      return promise;\n    };\n\n    toWrap[pointCut].pre.forEach(function(args) {\n      args[0] = newName;\n      _this.$pre.apply(_this, args);\n    });\n    toWrap[pointCut].post.forEach(function(args) {\n      args[0] = newName;\n      _this.$post.apply(_this, args);\n    });\n  });\n  return _this;\n};\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners('error').length) {\n    this.emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  } else if (this.listeners && this.listeners('error').length) {\n    this.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  var defaultOptions = {\n    transform: true,\n    json: json,\n    retainKeyOrder: this.schema.options.retainKeyOrder\n  };\n\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && utils.getFunctionName(options.constructor) === 'Object') ||\n      (options && options._useSchemaOptions)) {\n    if (json) {\n      options = this.schema.options.toJSON ?\n        clone(this.schema.options.toJSON) :\n        {};\n      options.json = true;\n      options._useSchemaOptions = true;\n    } else {\n      options = this.schema.options.toObject ?\n        clone(this.schema.options.toObject) :\n        {};\n      options.json = false;\n      options._useSchemaOptions = true;\n    }\n  }\n\n  for (var key in defaultOptions) {\n    if (options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  ('minimize' in options) || (options.minimize = this.schema.options.minimize);\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  var originalTransform = options.transform;\n\n  options._isNested = true;\n\n  var ret = clone(this._doc, options) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, 'paths', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, 'virtuals', options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  var transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform === true ||\n      (this.schema.options.toObject && transform)) {\n    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    var xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain javascript object, ready for storage in MongoDB.\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters)\n * - `virtuals` apply virtual getters (can override `getters` option)\n * - `minimize` remove empty objects (defaults to true)\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)\n * - `versionKey` whether to include the version key (defaults to true)\n * - `retainKeyOrder` keep the order of object keys. If this is set to true, `Object.keys(new Doc({ a: 1, b: 2}).toObject())` will always produce `['a', 'b']` (defaults to false)\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * _Note: if you call `toObject` and pass any options, the transform declared in your schema options will __not__ be applied. To force its application pass `transform: true`_\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     var doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id' });                  // { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * Transforms are applied _only to the document and are not applied to sub-documents_.\n *\n * Transforms, like all of these options, are also available for `toJSON`.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\nfunction minimize(obj) {\n  var keys = Object.keys(obj),\n      i = keys.length,\n      hasKeys,\n      key,\n      val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isObject(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n      ? obj\n      : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @param {String} type either `virtuals` or `paths`\n * @return {Object} `json`\n */\n\nfunction applyGetters(self, json, type, options) {\n  var schema = self.schema,\n      paths = Object.keys(schema[type]),\n      i = paths.length,\n      path;\n\n  while (i--) {\n    path = paths[i];\n\n    var parts = path.split('.'),\n        plen = parts.length,\n        last = plen - 1,\n        branch = json,\n        part;\n\n    for (var ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      if (ii === last) {\n        branch[part] = clone(self.get(path), options);\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @api public\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n */\n\nDocument.prototype.inspect = function(options) {\n  var isPOJO = options &&\n    utils.getFunctionName(options.constructor) === 'Object';\n  var opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n    opts.retainKeyOrder = true;\n  }\n  return this.toObject(opts);\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n */\n\nDocument.prototype.toString = function() {\n  return inspect(this.inspect());\n};\n\n/**\n * Returns true if the Document stores the same data as doc.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  var tid = this.get('_id');\n  var docid = doc.get ? doc.get('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n      ? tid.equals(docid)\n      : tid === docid;\n};\n\n/**\n * Populates document references, executing the `callback` when complete.\n * If you want to use promises instead, use this function with\n * [`execPopulate()`](#document_Document-execPopulate)\n *\n * ####Example:\n *\n *     doc\n *     .populate('company')\n *     .populate({\n *       path: 'notes',\n *       match: /airline/,\n *       select: 'text',\n *       model: 'modelName'\n *       options: opts\n *     }, function (err, user) {\n *       assert(doc._id === user._id) // the document itself is passed\n *     })\n *\n *     // summary\n *     doc.populate(path)                   // not executed\n *     doc.populate(options);               // not executed\n *     doc.populate(path, callback)         // executed\n *     doc.populate(options, callback);     // executed\n *     doc.populate(callback);              // executed\n *     doc.populate(options).execPopulate() // executed, returns promise\n *\n *\n * ####NOTE:\n *\n * Population does not occur unless a `callback` is passed *or* you explicitly\n * call `execPopulate()`.\n * Passing the same path a second time will overwrite the previous path options.\n * See [Model.populate()](#model_Model.populate) for explaination of options.\n *\n * @see Model.populate #model_Model.populate\n * @see Document.execPopulate #document_Document-execPopulate\n * @param {String|Object} [path] The path to populate or an options object\n * @param {Function} [callback] When passed, population is invoked\n * @api public\n * @return {Document} this\n */\n\nDocument.prototype.populate = function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  var pop = this.$__.populate || (this.$__.populate = {});\n  var args = utils.args(arguments);\n  var fn;\n\n  if (typeof args[args.length - 1] === 'function') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    var res = utils.populate.apply(null, args);\n    for (var i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    var paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    paths.__noPromise = true;\n    this.constructor.populate(this, paths, fn);\n  }\n\n  return this;\n};\n\n/**\n * Explicitly executes population and returns a promise. Useful for ES2015\n * integration.\n *\n * ####Example:\n *\n *     var promise = doc.\n *       populate('company').\n *       populate({\n *         path: 'notes',\n *         match: /airline/,\n *         select: 'text',\n *         model: 'modelName'\n *         options: opts\n *       }).\n *       execPopulate();\n *\n *     // summary\n *     doc.execPopulate().then(resolve, reject);\n *\n *\n * @see Document.populate #document_Document-populate\n * @api public\n * @return {Promise} promise that resolves to the document when population is done\n */\n\nDocument.prototype.execPopulate = function() {\n  var Promise = PromiseProvider.get();\n  var _this = this;\n  return new Promise.ES6(function(resolve, reject) {\n    _this.populate(function(error, res) {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, undefined is returned.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    var v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, this is a no-op.\n *\n * @param {String} path\n * @see Document.populate #document_Document-populate\n * @api public\n */\n\nDocument.prototype.depopulate = function(path) {\n  var populatedIds = this.populated(path);\n  if (!populatedIds) {\n    return;\n  }\n  delete this.$__.populated[path];\n  this.set(path, populatedIds);\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n"]},"metadata":{},"sourceType":"script"}