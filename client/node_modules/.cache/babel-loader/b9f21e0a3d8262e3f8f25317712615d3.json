{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nvar SchemaType = require('../schematype');\n\nvar Subdocument = require('../types/subdocument');\n\nvar castToNumber = require('./operators/helpers').castToNumber;\n\nvar geospatial = require('./operators/geospatial');\n\nmodule.exports = Embedded;\n/**\n * Sub-schema schematype constructor\n *\n * @param {Schema} schema\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction Embedded(schema, path, options) {\n  var _embedded = function (value, path, parent) {\n    var _this = this;\n\n    Subdocument.apply(this, arguments);\n    this.$parent = parent;\n\n    if (parent) {\n      parent.on('save', function () {\n        _this.emit('save', _this);\n      });\n      parent.on('isNew', function (val) {\n        _this.isNew = val;\n\n        _this.emit('isNew', val);\n      });\n    }\n  };\n\n  _embedded.prototype = Object.create(Subdocument.prototype);\n\n  _embedded.prototype.$__setSchema(schema);\n\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.prototype.$basePath = path;\n\n  _embedded.prototype.toBSON = function () {\n    return this.toObject({\n      transform: false,\n      retainKeyOrder: schema.options.retainKeyOrder,\n      virtuals: false\n    });\n  }; // apply methods\n\n\n  for (var i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  } // apply statics\n\n\n  for (i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  this.caster = _embedded;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\nEmbedded.prototype = Object.create(SchemaType.prototype);\n/**\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\nEmbedded.prototype.$conditionalHandlers.$geoWithin = function (val) {\n  return {\n    $geometry: this.castForQuery(val.$geometry)\n  };\n};\n/*!\n * ignore\n */\n\n\nEmbedded.prototype.$conditionalHandlers.$near = Embedded.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\nEmbedded.prototype.$conditionalHandlers.$within = Embedded.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\nEmbedded.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;\nEmbedded.prototype.$conditionalHandlers.$minDistance = castToNumber;\nEmbedded.prototype.$conditionalHandlers.$maxDistance = castToNumber;\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nEmbedded.prototype.cast = function (val, doc, init) {\n  if (val && val.$isSingleNested) {\n    return val;\n  }\n\n  var subdoc = new this.caster(void 0, doc ? doc.$__.selected : void 0, doc);\n\n  if (init) {\n    subdoc.init(val);\n  } else {\n    subdoc.set(val, undefined, true);\n  }\n\n  return subdoc;\n};\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\n\nEmbedded.prototype.castForQuery = function ($conditional, val) {\n  var handler;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n\n    return handler.call(this, val);\n  }\n\n  val = $conditional;\n\n  if (val == null) {\n    return val;\n  }\n\n  return new this.caster(val);\n};\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\n\nEmbedded.prototype.doValidate = function (value, fn, scope) {\n  SchemaType.prototype.doValidate.call(this, value, function (error) {\n    if (error) {\n      return fn(error);\n    }\n\n    if (!value) {\n      return fn(null);\n    }\n\n    value.validate(fn, {\n      __noPromise: true\n    });\n  }, scope);\n};\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\n\nEmbedded.prototype.doValidateSync = function (value, scope) {\n  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n\n  if (schemaTypeError) {\n    return schemaTypeError;\n  }\n\n  if (!value) {\n    return;\n  }\n\n  return value.validateSync();\n};","map":{"version":3,"sources":["C:/Users/SATAN/darelist/client/node_modules/mongoose/lib/schema/embedded.js"],"names":["SchemaType","require","Subdocument","castToNumber","geospatial","module","exports","Embedded","schema","path","options","_embedded","value","parent","_this","apply","arguments","$parent","on","emit","val","isNew","prototype","Object","create","$__setSchema","$isSingleNested","$basePath","toBSON","toObject","transform","retainKeyOrder","virtuals","i","methods","statics","caster","call","$conditionalHandlers","$geoWithin","$geometry","castForQuery","$near","$nearSphere","cast$near","$within","cast$within","$geoIntersects","cast$geoIntersects","$minDistance","$maxDistance","cast","doc","init","subdoc","$__","selected","set","undefined","$conditional","handler","length","Error","doValidate","fn","scope","error","validate","__noPromise","doValidateSync","schemaTypeError","validateSync"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar SchemaType = require('../schematype');\nvar Subdocument = require('../types/subdocument');\nvar castToNumber = require('./operators/helpers').castToNumber;\nvar geospatial = require('./operators/geospatial');\n\nmodule.exports = Embedded;\n\n/**\n * Sub-schema schematype constructor\n *\n * @param {Schema} schema\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction Embedded(schema, path, options) {\n  var _embedded = function(value, path, parent) {\n    var _this = this;\n    Subdocument.apply(this, arguments);\n    this.$parent = parent;\n    if (parent) {\n      parent.on('save', function() {\n        _this.emit('save', _this);\n      });\n\n      parent.on('isNew', function(val) {\n        _this.isNew = val;\n        _this.emit('isNew', val);\n      });\n    }\n  };\n  _embedded.prototype = Object.create(Subdocument.prototype);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.prototype.$basePath = path;\n  _embedded.prototype.toBSON = function() {\n    return this.toObject({\n      transform: false,\n      retainKeyOrder: schema.options.retainKeyOrder,\n      virtuals: false\n    });\n  };\n\n  // apply methods\n  for (var i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  this.caster = _embedded;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\nEmbedded.prototype = Object.create(SchemaType.prototype);\n\n/**\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\nEmbedded.prototype.$conditionalHandlers.$geoWithin = function(val) {\n  return { $geometry: this.castForQuery(val.$geometry) };\n};\n\n/*!\n * ignore\n */\n\nEmbedded.prototype.$conditionalHandlers.$near =\nEmbedded.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\n\nEmbedded.prototype.$conditionalHandlers.$within =\nEmbedded.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\n\nEmbedded.prototype.$conditionalHandlers.$geoIntersects =\n  geospatial.cast$geoIntersects;\n\nEmbedded.prototype.$conditionalHandlers.$minDistance = castToNumber;\nEmbedded.prototype.$conditionalHandlers.$maxDistance = castToNumber;\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nEmbedded.prototype.cast = function(val, doc, init) {\n  if (val && val.$isSingleNested) {\n    return val;\n  }\n  var subdoc = new this.caster(void 0, doc ? doc.$__.selected : void 0, doc);\n  if (init) {\n    subdoc.init(val);\n  } else {\n    subdoc.set(val, undefined, true);\n  }\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nEmbedded.prototype.castForQuery = function($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  if (val == null) {\n    return val;\n  }\n\n  return new this.caster(val);\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\nEmbedded.prototype.doValidate = function(value, fn, scope) {\n  SchemaType.prototype.doValidate.call(this, value, function(error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n    value.validate(fn, {__noPromise: true});\n  }, scope);\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nEmbedded.prototype.doValidateSync = function(value, scope) {\n  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n  if (schemaTypeError) {\n    return schemaTypeError;\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n"]},"metadata":{},"sourceType":"script"}