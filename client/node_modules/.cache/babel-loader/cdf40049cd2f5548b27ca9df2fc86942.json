{"ast":null,"code":"// TODO Add in pre and post skipping options\nmodule.exports = {\n  /**\n   *  Declares a new hook to which you can add pres and posts\n   *  @param {String} name of the function\n   *  @param {Function} the method\n   *  @param {Function} the error handler callback\n   */\n  hook: function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === 'object') {\n      for (var k in name) {\n        // `name` is a hash of hookName->hookFn\n        this.hook(k, name[k]);\n      }\n\n      return;\n    }\n\n    var proto = this.prototype || this,\n        pres = proto._pres = proto._pres || {},\n        posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this,\n          hookArgs // arguments eventually passed to the hook - are mutable\n      ,\n          lastArg = arguments[arguments.length - 1],\n          pres = this._pres[name],\n          posts = this._posts[name],\n          _total = pres.length,\n          _current = -1,\n          _asyncsLeft = proto[name].numAsyncPres,\n          _asyncsDone = function (err) {\n        if (err) {\n          return handleError(err);\n        }\n\n        --_asyncsLeft || _done.apply(self, hookArgs);\n      },\n          handleError = function (err) {\n        if ('function' == typeof lastArg) return lastArg(err);\n        if (errorCb) return errorCb.call(self, err);\n        throw err;\n      },\n          _next = function () {\n        if (arguments[0] instanceof Error) {\n          return handleError(arguments[0]);\n        }\n\n        var _args = Array.prototype.slice.call(arguments),\n            currPre,\n            preArgs;\n\n        if (_args.length && !(arguments[0] == null && typeof lastArg === 'function')) hookArgs = _args;\n\n        if (++_current < _total) {\n          currPre = pres[_current];\n          if (currPre.isAsync && currPre.length < 2) throw new Error(\"Your pre must have next and done arguments -- e.g., function (next, done, ...)\");\n          if (currPre.length < 1) throw new Error(\"Your pre must have a next argument -- e.g., function (next, ...)\");\n          preArgs = (currPre.isAsync ? [once(_next), once(_asyncsDone)] : [once(_next)]).concat(hookArgs);\n          return currPre.apply(self, preArgs);\n        } else if (!_asyncsLeft) {\n          return _done.apply(self, hookArgs);\n        }\n      },\n          _done = function () {\n        var args_ = Array.prototype.slice.call(arguments),\n            ret,\n            total_,\n            current_,\n            next_,\n            done_,\n            postArgs;\n\n        if (_current === _total) {\n          next_ = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n\n            var args_ = Array.prototype.slice.call(arguments, 1),\n                currPost,\n                postArgs;\n            if (args_.length) hookArgs = args_;\n\n            if (++current_ < total_) {\n              currPost = posts[current_];\n              if (currPost.length < 1) throw new Error(\"Your post must have a next argument -- e.g., function (next, ...)\");\n              postArgs = [once(next_)].concat(hookArgs);\n              return currPost.apply(self, postArgs);\n            } else if (typeof lastArg === 'function') {\n              // All post handlers are done, call original callback function\n              return lastArg.apply(self, arguments);\n            }\n          }; // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n          // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n\n\n          if (typeof lastArg === 'function') {\n            args_[args_.length - 1] = once(next_);\n          }\n\n          total_ = posts.length;\n          current_ = -1;\n          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n          if (total_ && typeof lastArg !== 'function') return next_(); // no callback provided, execute next_() manually\n\n          return ret;\n        }\n      };\n\n      return _next.apply(this, arguments);\n    };\n\n    proto[name].numAsyncPres = 0;\n    return this;\n  },\n  pre: function (name, isAsync, fn, errorCb) {\n    if ('boolean' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n\n    var proto = this.prototype || this,\n        pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  },\n  post: function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n\n    var proto = this.prototype || this,\n        posts = proto._posts = proto._posts || {};\n\n    this._lazySetupHooks(proto, name);\n\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  },\n  removePre: function (name, fnToRemove) {\n    var proto = this.prototype || this,\n        pres = proto._pres || proto._pres || {};\n    if (!pres[name]) return this;\n\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter(function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n\n    return this;\n  },\n  removePost: function (name, fnToRemove) {\n    var proto = this.prototype || this,\n        posts = proto._posts || proto._posts || {};\n    if (!posts[name]) return this;\n\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter(function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n\n    return this;\n  },\n  _lazySetupHooks: function (proto, methodName, errorCb) {\n    if ('undefined' === typeof proto[methodName].numAsyncPres) {\n      this.hook(methodName, proto[methodName], errorCb);\n    }\n  }\n};\n\nfunction once(fn, scope) {\n  return function fnWrapper() {\n    if (fnWrapper.hookCalled) return;\n    fnWrapper.hookCalled = true;\n    fn.apply(scope, arguments);\n  };\n}","map":{"version":3,"sources":["C:/Users/SATAN/darelist/client/node_modules/hooks-fixed/hooks.js"],"names":["module","exports","hook","name","fn","errorCb","arguments","length","k","proto","prototype","pres","_pres","posts","_posts","self","hookArgs","lastArg","_total","_current","_asyncsLeft","numAsyncPres","_asyncsDone","err","handleError","_done","apply","call","_next","Error","_args","Array","slice","currPre","preArgs","isAsync","once","concat","args_","ret","total_","current_","next_","done_","postArgs","currPost","pre","_lazySetupHooks","push","post","removePre","fnToRemove","filter","currFn","removePost","methodName","scope","fnWrapper","hookCalled"],"mappings":"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","sourcesContent":["// TODO Add in pre and post skipping options\nmodule.exports = {\n  /**\n   *  Declares a new hook to which you can add pres and posts\n   *  @param {String} name of the function\n   *  @param {Function} the method\n   *  @param {Function} the error handler callback\n   */\n  hook: function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === 'object') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _asyncsDone = function(err) {\n            if (err) {\n              return handleError(err);\n            }\n            --_asyncsLeft || _done.apply(self, hookArgs);\n          }\n        , handleError = function(err) {\n            if ('function' == typeof lastArg)\n              return lastArg(err);\n            if (errorCb) return errorCb.call(self, err);\n            throw err;\n          }\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === 'function'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error(\"Your pre must have next and done arguments -- e.g., function (next, done, ...)\");\n              if (currPre.length < 1)\n                throw new Error(\"Your pre must have a next argument -- e.g., function (next, ...)\");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!_asyncsLeft) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error(\"Your post must have a next argument -- e.g., function (next, ...)\");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === 'function'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === 'function'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  },\n\n  pre: function (name, isAsync, fn, errorCb) {\n    if ('boolean' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  },\n  post: function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  },\n  removePre: function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  },\n  removePost: function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all post callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  },\n  \n  _lazySetupHooks: function (proto, methodName, errorCb) {\n    if ('undefined' === typeof proto[methodName].numAsyncPres) {\n      this.hook(methodName, proto[methodName], errorCb);\n    }\n  }\n};\n\nfunction once (fn, scope) {\n  return function fnWrapper () {\n    if (fnWrapper.hookCalled) return;\n    fnWrapper.hookCalled = true;\n    fn.apply(scope, arguments);\n  };\n}\n"]},"metadata":{},"sourceType":"script"}